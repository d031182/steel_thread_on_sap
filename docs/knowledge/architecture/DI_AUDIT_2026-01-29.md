# Dependency Injection Audit - January 29, 2026

## Executive Summary

**Status**: üî¥ **2 CRITICAL DI VIOLATIONS FOUND**

Comprehensive audit of all modules revealed violations of the strict dependency injection architecture. Both violations involve reaching into HANADataSource internals to access the `.connection` property for arbitrary SQL execution.

---

## Critical Violations Found

### Violation 1: SQL Execution Module
**File**: `modules/sql_execution/backend/api.py`  
**Line**: 61  
**Code**:
```python
result = hana_data_source.connection.execute_query(sql)
```

**Problem**:
- Reaches into HANADataSource internal `.connection` property
- Creates tight coupling to HANA implementation
- Would break if switching to different data source

**Impact**: HIGH - Core functionality (SQL execution) is implementation-dependent

---

### Violation 2: Data Products Module
**File**: `modules/data_products/backend/api.py`  
**Line**: 266  
**Code**:
```python
result = current_app.hana_data_source.connection.execute_query(sql)
```

**Problem**:
- Same violation in `/api/execute-sql` endpoint
- Direct access to HANADataSource internals
- Violates interface abstraction

**Impact**: MEDIUM - Endpoint exists but SQL Execution module preferred

---

## Root Cause Analysis

### The Core Problem

The `DataSource` interface (`core/interfaces/data_source.py`) does NOT include an `execute_query()` method. Current interface only supports:

‚úÖ `get_data_products()` - Get data product list  
‚úÖ `get_tables()` - Get tables in schema  
‚úÖ `get_table_structure()` - Get column definitions  
‚úÖ `query_table()` - Query with structured parameters  
‚úÖ `get_csn_definition()` - Get CSN metadata  

‚ùå `execute_query(sql)` - **MISSING** - Execute arbitrary SQL

### Why This Matters

**Current State (WRONG)**:
```python
# Modules reach into implementation
hana_data_source.connection.execute_query(sql)  # ‚ùå Implementation coupling
```

**If we add PostgreSQL**:
```python
# Would need to check type everywhere
if hasattr(data_source, 'connection'):  # ‚ùå Type checking anti-pattern
    result = data_source.connection.execute_query(sql)
```

**Architectural Vision (CORRECT)**:
```python
# Use interface method
result = data_source.execute_query(sql)  # ‚úÖ Works with ANY source
```

---

## Solution Options

### Option 1: Add execute_query() to DataSource Interface ‚≠ê RECOMMENDED

**Pros**:
- Clean, simple solution
- All data sources can execute SQL
- One interface for everything
- Swap data sources with zero code changes

**Cons**:
- SQLite may not want arbitrary SQL execution
- Adds method to interface

**Implementation**:
```python
# core/interfaces/data_source.py
@abstractmethod
def execute_query(self, sql: str, params: tuple = None) -> Dict:
    """
    Execute arbitrary SQL query
    
    Args:
        sql: SQL query string
        params: Optional query parameters
    
    Returns:
        Dictionary with:
        - success: bool
        - rows: List[Dict]
        - columns: List[str]
        - rowCount: int
        - executionTime: float
        - error: Dict (if failed)
    """
    pass
```

**Then update implementations**:
- `HANADataSource.execute_query()` - Delegate to connection
- `SQLiteDataSource.execute_query()` - Delegate to service

**Then fix violations**:
```python
# modules/sql_execution/backend/api.py (Line 61)
result = hana_data_source.execute_query(sql)  # ‚úÖ Uses interface

# modules/data_products/backend/api.py (Line 266)  
result = current_app.hana_data_source.execute_query(sql)  # ‚úÖ Uses interface
```

---

### Option 2: Create QueryExecutor Interface

**Pros**:
- Separates concerns (data products vs. SQL execution)
- DataSource stays focused on structured queries
- QueryExecutor can have different implementations

**Cons**:
- More complex (two interfaces)
- Need to inject TWO dependencies
- app.py needs both `data_source` and `query_executor`

**Implementation**:
```python
# core/interfaces/query_executor.py
class QueryExecutor(ABC):
    @abstractmethod
    def execute_query(self, sql: str) -> Dict:
        pass
```

**Not recommended** - Adds complexity without clear benefit

---

## Recommendations

### Immediate Actions

1. ‚úÖ **Add `execute_query()` to DataSource interface**
   - Extend the contract with arbitrary SQL capability
   - This is a legitimate need for data exploration

2. ‚úÖ **Implement in both sources**:
   - `HANADataSource.execute_query()` ‚Üí delegate to `self.connection.execute_query()`
   - `SQLiteDataSource.execute_query()` ‚Üí delegate to `self.service.execute_query()`

3. ‚úÖ **Fix violations**:
   - `sql_execution/backend/api.py:61`
   - `data_products/backend/api.py:266`

4. ‚úÖ **Test thoroughly**:
   - Verify SQL execution works via interface
   - Test with both HANA and SQLite

5. ‚úÖ **Document in PROJECT_TRACKER**:
   - Record the violation and fix
   - Add to architecture principles

---

## Testing Checklist

After implementing fix:

- [ ] SQL Execution module works with HANA
- [ ] SQL Execution module works with SQLite
- [ ] Data Products execute-sql endpoint works
- [ ] No direct `.connection` or `.service` access in modules
- [ ] Interface swap test: Can switch HANA ‚Üî SQLite with config change only

---

## Long-term Architecture Principles

### Golden Rules (MUST FOLLOW)

1. **Never access implementation internals**
   - ‚ùå `data_source.connection`
   - ‚ùå `data_source.service`  
   - ‚ùå `hasattr(data_source, 'connection')`
   - ‚úÖ `data_source.execute_query()`

2. **Program to interfaces, not implementations**
   - Modules depend on `DataSource` interface
   - Don't import `HANADataSource` or `SQLiteDataSource` directly
   - Use dependency injection from app.py

3. **Interface completeness**
   - If modules need a capability, add it to the interface
   - Don't work around missing interface methods
   - Missing method = incomplete interface design

4. **Swap test**
   - Any feature should work by changing ONE line in app.py config
   - No code changes in modules
   - No type checking (`hasattr`, `isinstance`)

---

## Success Criteria

**BEFORE** (Current State):
```python
# ‚ùå Implementation coupling
hana_data_source.connection.execute_query(sql)

# Cannot swap to SQLite without code changes
```

**AFTER** (Target State):
```python
# ‚úÖ Interface usage
data_source.execute_query(sql)

# Swap HANA ‚Üî SQLite: Change 1 line in app.py config
# Zero module code changes required
```

---

## Audit Results Summary

| Category | Status | Details |
|----------|--------|---------|
| hasattr() checks | ‚úÖ PASS | No implementation checks found |
| Direct .connection access | üî¥ FAIL | 2 violations (sql_execution, data_products) |
| Direct .service access | ‚úÖ PASS | Only in implementations (allowed) |
| Direct .db_path access | ‚úÖ PASS | Only in implementations (allowed) |
| Interface completeness | üî¥ FAIL | Missing execute_query() method |

**Overall**: üî¥ **ARCHITECTURE VIOLATIONS - FIX REQUIRED**

---

## Next Steps

1. Implement Option 1 (add execute_query to interface)
2. Update HANADataSource and SQLiteDataSource
3. Fix both violations
4. Test with both data sources
5. Update PROJECT_TRACKER
6. Commit with detailed explanation

**Estimated effort**: 30-45 minutes  
**Priority**: HIGH - Core architectural principle violated

---

*Audit conducted: 2026-01-29*  
*Auditor: AI Assistant (Comprehensive DI review)*  
*Next audit: After every major feature addition*