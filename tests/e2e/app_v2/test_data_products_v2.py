"""
Auto-generated E2E tests for data_products_v2

Generated by: Gu Wu (顾武) Test Generator
Source: Feng Shui (风水) Multi-Agent Analysis
Date: 2026-02-08T18:34:53.139767

DO NOT EDIT - Regenerate from Feng Shui report if validation changes.
"""

import pytest
from pathlib import Path
import json


# Module under test
MODULE_NAME = "data_products_v2"
MODULE_PATH = Path(f"modules/{MODULE_NAME}")



@pytest.fixture
def module_config():
    """Load module.json configuration"""
    config_path = MODULE_PATH / "module.json"
    return json.loads(config_path.read_text())


@pytest.fixture
def app_v2_base_url():
    """Base URL for App V2 (assumes local development)"""
    return "http://localhost:5000"



@pytest.mark.e2e
@pytest.mark.app_v2
def test_module_registry_discovery():
    """
    Test: Module is discoverable by FrontendModuleRegistry
    
    Feng Shui Check: Module Registry Discovery
    Status: CRITICAL - Ensures module appears in API
    
    This test validates that:
    1. Module is discovered by backend registry
    2. Module metadata is correct
    3. Module appears in /api/modules/frontend-registry
    """
    from core.services.frontend_module_registry import FrontendModuleRegistry
    
    # Test backend registry discovery
    registry = FrontendModuleRegistry()
    modules = registry.get_frontend_modules()
    module_ids = [m['id'] for m in modules]
    
    assert MODULE_NAME in module_ids, \
        f"Module '{MODULE_NAME}' not discovered by FrontendModuleRegistry. " \
        f"Found modules: {module_ids}"
    
    # Verify module metadata
    module_data = registry.get_module_by_id(MODULE_NAME)
    assert module_data is not None, f"Module '{MODULE_NAME}' has no metadata"
    
    # Verify required fields
    required_fields = ['id', 'name', 'version', 'icon', 'frontend']
    for field in required_fields:
        assert field in module_data, f"Module metadata missing field: {field}"
    
    # Verify frontend configuration
    frontend_config = module_data['frontend']
    assert 'scripts' in frontend_config, "Module frontend config missing 'scripts'"
    assert 'entry_point' in frontend_config, "Module frontend config missing 'entry_point'"
    assert 'route' in frontend_config, "Module frontend config missing 'route'"
    
    # Verify module is enabled
    config_path = MODULE_PATH / "module.json"
    import json
    config = json.loads(config_path.read_text())
    assert config.get('enabled', True), f"Module '{MODULE_NAME}' is disabled"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_scripts_accessible(module_config, app_v2_base_url):
    """
    Test: Frontend scripts are accessible via HTTP
    
    Feng Shui Check: Scripts Accessible
    Status: PASS
    Issues Found: 0
    """
    import requests
    
    if 'frontend' not in module_config:
        pytest.skip("Module has no frontend configuration")
    
    scripts = module_config['frontend'].get('scripts', [])
    
    for script in scripts:
        script_url = f"{app_v2_base_url}/v2/{script}"
        response = requests.get(script_url, timeout=5)
        
        assert response.status_code == 200, \
            f"Script not accessible: {script} ({response.status_code})"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_navigation_consistency(module_config):
    """
    Test: Navigation structure is consistent
    
    Feng Shui Check: Navigation Consistency
    Status: PASS
    Issues Found: 0
    """
    if 'frontend' not in module_config:
        pytest.skip("Module has no frontend configuration")
    
    frontend_config = module_config['frontend']
    
    # Verify module has required navigation fields
    assert 'entry_point' in frontend_config, "Missing entry_point in frontend config"
    assert 'scripts' in frontend_config, "Missing scripts in frontend config"
    
    # If category is declared, ensure it's valid
    if 'category' in frontend_config:
        category = frontend_config['category']
        valid_categories = ['infrastructure', 'features', 'analytics']
        assert category in valid_categories, \
            f"Invalid category: {category}. Must be one of {valid_categories}"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_interface_compliance():
    """
    Test: Implementations match their interfaces
    
    Feng Shui Check: Interface Compliance
    Status: PASS
    Issues Found: 0
    """
    # Check NoOpLogger implements complete ILogger interface
    noop_logger = Path("app_v2/static/js/adapters/NoOpLogger.js")
    ilogger = Path("app_v2/static/js/interfaces/ILogger.js")
    
    assert noop_logger.exists(), "NoOpLogger.js not found"
    assert ilogger.exists(), "ILogger.js not found"
    
    # Extract methods from interface
    import re
    ilogger_content = ilogger.read_text()
    interface_methods = set(re.findall(r'^\s*(\w+)\s*\([^)]*\)\s*{', ilogger_content, re.MULTILINE))
    
    # Extract methods from implementation
    noop_content = noop_logger.read_text()
    impl_methods = set(re.findall(r'^\s*(\w+)\s*\([^)]*\)\s*{', noop_content, re.MULTILINE))
    
    # Verify all interface methods are implemented
    missing_methods = interface_methods - impl_methods
    assert not missing_methods, \
        f"NoOpLogger missing methods: {', '.join(missing_methods)}"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_dynamic_loading_compatibility(module_config):
    """
    Test: Module exports are compatible with dynamic loading
    
    Feng Shui Check: Dynamic Loading Compatibility
    Status: PASS
    Issues Found: 0
    """
    if 'frontend' not in module_config:
        pytest.skip("Module has no frontend configuration")
    
    scripts = module_config['frontend'].get('scripts', [])
    
    for script in scripts:
        script_path = Path(script)
        
        if not script_path.exists():
            pytest.skip(f"Script not found: {script}")
        
        content = script_path.read_text()
        
        # Check for problematic ES6 exports
        problematic_patterns = ['export function', 'export const', 'export class']
        found_patterns = [p for p in problematic_patterns if p in content]
        
        assert not found_patterns, \
            f"ES6 exports detected in {script}: {found_patterns} " \
            f"(incompatible with dynamic <script> loading). " \
            f"Use window.FunctionName = ... instead."


@pytest.mark.e2e
@pytest.mark.app_v2
def test_sapui5_rendering_safety():
    """
    Test: SAPUI5 rendering follows safe patterns
    
    Feng Shui Check: SAPUI5 Rendering Safety
    Status: FAIL
    Issues Found: 1
    """
    router_service = Path("app_v2/static/js/core/RouterService.js")
    
    assert router_service.exists(), "RouterService.js not found"
    
    content = router_service.read_text()
    
    # Check for problematic patterns
    problematic_patterns = {
        'document.createElement': 'Temp DOM element creation',
        'placeAt': 'placeAt() usage (can cause lifecycle issues)',
    }
    
    warnings = []
    for pattern, description in problematic_patterns.items():
        if pattern in content:
            warnings.append(f"{description} detected in RouterService")
    
    # This is a warning, not a failure (may be intentional)
    if warnings:
        import warnings as warn_module
        warn_module.warn(
            "Potential SAPUI5 rendering issues detected:\n" + 
            "\n".join(f"  - {w}" for w in warnings),
            UserWarning
        )


@pytest.mark.e2e
@pytest.mark.app_v2
def test_backend_api_registration():
    """
    Test: Backend API blueprint is properly registered
    
    Feng Shui Check: Backend Registration
    Status: NEW - Tests backend architecture
    
    Validates:
    1. module.json has backend config
    2. Blueprint exists and exports correctly
    3. API endpoints are accessible
    """
    config_path = MODULE_PATH / "module.json"
    config = json.loads(config_path.read_text())
    
    # Verify backend configuration exists
    assert 'backend' in config, "Module missing backend configuration"
    backend_config = config['backend']
    
    # Verify required fields
    assert 'blueprint' in backend_config, "Backend config missing blueprint"
    assert 'mount_path' in backend_config, "Backend config missing mount_path"
    
    # Verify blueprint path format
    blueprint_spec = backend_config['blueprint']
    assert ':' in blueprint_spec, f"Invalid blueprint spec: {blueprint_spec}"
    
    module_path, blueprint_name = blueprint_spec.split(':')
    assert module_path.startswith('modules.data_products_v2.backend'), \
        f"Blueprint not in backend module: {module_path}"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_backend_api_endpoints(app_v2_base_url):
    """
    Test: Backend API endpoints are functional
    
    Feng Shui Check: API Endpoint Functionality
    Status: NEW - Tests API layer
    
    Validates:
    1. Main endpoint returns valid JSON
    2. Source parameter works (sqlite/hana)
    3. Response structure is correct
    """
    import requests
    
    # Test main endpoint with SQLite source
    response = requests.get(
        f"{app_v2_base_url}/api/v2/data-products/?source=sqlite",
        timeout=5
    )
    
    assert response.status_code == 200, \
        f"API endpoint failed: {response.status_code}"
    
    data = response.json()
    
    # Verify response structure
    assert 'success' in data, "Response missing 'success' field"
    assert 'source' in data, "Response missing 'source' field"
    assert 'data_products' in data, "Response missing 'data_products' field"
    assert 'count' in data, "Response missing 'count' field"
    
    # Verify success and source
    assert data['success'] is True, "API returned success=False"
    assert data['source'] == 'sqlite', "API returned wrong source"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_repository_pattern_compliance():
    """
    Test: Repository Pattern properly implemented
    
    Feng Shui Check: Repository Pattern Compliance
    Status: NEW - Tests architecture patterns
    
    Validates:
    1. Interface exists (IDataProductRepository)
    2. Implementations exist (SQLite, HANA)
    3. Factory exists and follows pattern
    4. All use dependency injection
    """
    # Check interface exists
    interface_path = Path("core/interfaces/data_product_repository.py")
    assert interface_path.exists(), "IDataProductRepository interface not found"
    
    # Check implementations exist
    sqlite_repo = MODULE_PATH / "repositories/sqlite_data_product_repository.py"
    hana_repo = MODULE_PATH / "repositories/hana_data_product_repository.py"
    factory = MODULE_PATH / "repositories/repository_factory.py"
    
    assert sqlite_repo.exists(), "SQLiteDataProductRepository not found"
    assert hana_repo.exists(), "HANADataProductRepository not found"
    assert factory.exists(), "DataProductRepositoryFactory not found"
    
    # Verify no hardwired database access (DI compliance)
    for repo_file in [sqlite_repo, hana_repo]:
        content = repo_file.read_text()
        
        # Should NOT hardwire paths
        violations = []
        if 'database/p2p_data.db' in content and '__init__' not in content:
            violations.append("Hardwired database path")
        if 'get_sqlite_db_path()' in content and 'import' not in content:
            violations.append("Direct path resolver call")
        
        assert not violations, \
            f"{repo_file.name} has DI violations: {', '.join(violations)}"


@pytest.mark.e2e
@pytest.mark.app_v2
def test_facade_pattern_compliance():
    """
    Test: Facade Pattern properly implemented
    
    Feng Shui Check: Facade Pattern Compliance
    Status: NEW - Tests business logic layer
    
    Validates:
    1. Facade exists and exports properly
    2. Facade uses repositories (not direct DB access)
    3. API uses facade (not repositories directly)
    """
    # Check facade exists
    facade_path = MODULE_PATH / "facade/data_products_facade.py"
    assert facade_path.exists(), "DataProductsFacade not found"
    
    # Verify facade uses factory (DI)
    facade_content = facade_path.read_text()
    assert 'DataProductRepositoryFactory' in facade_content, \
        "Facade not using factory pattern"
    assert 'IDataProductRepository' in facade_content, \
        "Facade not using interface abstraction"
    
    # Verify API uses facade (not repositories directly)
    api_path = MODULE_PATH / "backend/api.py"
    assert api_path.exists(), "API blueprint not found"
    
    api_content = api_path.read_text()
    assert 'DataProductsFacade' in api_content, \
        "API not using facade pattern"
    
    # API should NOT directly import repositories
    repo_imports = [
        'from modules.data_products_v2.repositories.sqlite',
        'from modules.data_products_v2.repositories.hana',
        'import SQLiteDataProductRepository',
        'import HANADataProductRepository'
    ]
    violations = [imp for imp in repo_imports if imp in api_content]
    
    assert not violations, \
        f"API has direct repository imports (should use facade): {violations}"


@pytest.mark.e2e
@pytest.mark.app_v2  
def test_feng_shui_architecture_compliance():
    """
    Test: Module passes Feng Shui architecture validation
    
    Feng Shui Check: Overall Architecture Quality
    Status: NEW - Comprehensive architecture validation
    
    Validates:
    1. Module structure correct
    2. No DI violations
    3. Proper layering (Interface → Repository → Facade → API)
    4. Clean exports
    """
    # Check module structure
    required_dirs = ['repositories', 'facade', 'backend', 'frontend']
    for dir_name in required_dirs:
        dir_path = MODULE_PATH / dir_name
        assert dir_path.exists(), f"Missing required directory: {dir_name}"
        
        # Check __init__.py exists (proper Python package)
        init_file = dir_path / "__init__.py"
        if dir_name != 'frontend':  # Frontend is JS
            assert init_file.exists(), f"Missing __init__.py in {dir_name}"
    
    # Verify no direct database access in API layer
    api_path = MODULE_PATH / "backend/api.py"
    api_content = api_path.read_text()
    
    direct_access_patterns = [
        'sqlite3.connect',
        'hdbcli.dbapi.connect',
        'database/p2p_data.db',
        '.connection.',
        '.db_path'
    ]
    
    violations = [p for p in direct_access_patterns if p in api_content]
    assert not violations, \
        f"API has direct database access (should use facade): {violations}"


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
