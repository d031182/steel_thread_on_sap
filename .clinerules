# Development Standards & Best Practices

**Version**: 2.1  
**Last Updated**: 2026-01-25 (7:36 PM - Architecture-First Enforcement Added)
**Purpose**: Core standards for P2P Data Products development

---

## âš ï¸ CRITICAL: ARCHITECTURE-FIRST ENFORCEMENT

**MANDATORY RULE**: When user discusses architecture for 90+ minutes, IMPLEMENT ARCHITECTURE FIRST!

### The Problem We're Preventing
- âŒ User spends 90 min discussing modular architecture
- âŒ AI ignores discussion, implements features with inline/hardwired code
- âŒ Result: Double work (implement â†’ refactor), fragile code, technical debt
- âŒ User frustration: "We could have avoided this!"

### The Correct Approach
- âœ… User discusses architecture for 90+ minutes â†’ **THAT IS THE PRIORITY**
- âœ… AI asks: "Should I implement the architecture discussed before adding features?"
- âœ… AI implements: Interfaces â†’ Modules â†’ Integration â†’ THEN features
- âœ… Result: Features built on solid foundation, zero refactoring needed

### Enforcement Checklist (AI MUST DO THIS)
Before implementing ANY feature, AI must ask in `<thinking>`:
1. â“ Has user discussed architecture extensively (60+ minutes)?
2. â“ Are there unimplemented architectural concepts (interfaces, registries, DI)?
3. â“ Am I about to hardwire code that should use the discussed architecture?
4. â“ Will this create technical debt that requires later refactoring?

**If ANY answer is YES**: STOP. Ask user: "Should I implement [architecture concept] first?"

### Examples of Architecture-First Signals
- User discusses "modular architecture" for 90+ minutes â†’ Implement modules FIRST
- User discusses "dependency injection" â†’ Create interfaces FIRST
- User discusses "plugin system" â†’ Create registry FIRST
- User discusses "abstraction layer" â†’ Create abstractions FIRST

### Time Math (Why This Matters)
- **Wrong Way**: 90 min discussion + feature implementation + refactoring = **3x effort**
- **Right Way**: 90 min discussion + architecture + features = **1.5x effort**
- **Savings**: 50% less work by doing architecture first!

### Never Say This
- âŒ "We can refactor later" (= technical debt)
- âŒ "Let's get it working first" (= wrong priority)
- âŒ "Architecture is overhead" (= it's INVESTMENT)

### Always Say This
- âœ… "Should I implement the architecture we discussed first?"
- âœ… "Let me create the interfaces before the implementations"
- âœ… "I'll build this on the modular foundation we designed"

---

## ğŸ¯ PRIORITY 1: ESSENTIAL WORKFLOWS

### 1. Knowledge Graph First â­ MANDATORY

**Before ANY work, check what we already know:**

```xml
<use_mcp_tool>
  <server_name>github.com/modelcontextprotocol/servers/tree/main/src/memory</server_name>
  <tool_name>search_nodes</tool_name>
  <arguments>{"query": "[relevant search terms]"}</arguments>
</use_mcp_tool>
```

**Why**: Prevents wasting 90 minutes re-investigating known topics

**At session end**: Store new learnings in knowledge graph

---

### 2. Knowledge Vault Documentation â­ MANDATORY

**ALL documentation â†’ `docs/knowledge/` vault**

**âœ… ALLOWED**:
- Files in `docs/knowledge/` subdirectories
- Module READMEs: `modules/[name]/README.md`
- Links: `[[Document Name]]` format

**âŒ FORBIDDEN**:
- .md files in root (except `.clinerules`, `PROJECT_TRACKER.md`, `README.md`)
- .md files in `docs/` outside knowledge vault
- Standalone planning/summary docs

**Workflow**:
1. Search existing docs: `<search_files path="docs/knowledge" regex="..."/>`
2. Create with [[wikilinks]] to 3-5 related docs
3. Update `docs/knowledge/INDEX.md`
4. Commit doc + INDEX together

**Reference**: `docs/knowledge/README.md`

---

### 3. Check Industry Standards First ğŸ’¡

**Before proposing solutions, validate against industry best practices**

**Process**:
- Research proven approaches
- Validate user's intuitive proposals
- Use established patterns (don't reinvent)
- Only create custom when no standard exists

**Benefits**: Save time, proven quality, better collaboration

### 3.1 Infrastructure-First Principle â­ CRITICAL

**NEVER build infrastructure without immediately integrating it**

**Rule**: When building core infrastructure (registries, resolvers, interfaces):
1. âœ… Design the architecture
2. âœ… Implement the infrastructure
3. âœ… Write tests for infrastructure
4. âœ… **IMMEDIATELY integrate into application code**
5. âœ… Test the integrated system
6. âœ… Only commit when integration is complete

**Why**: 
- Infrastructure without integration = technical debt
- Quick implementations create fragile, hardwired code
- Spending 2 hours on solid architecture > 30 minutes on quick code
- "Later refactoring" never happens - debt accumulates

**Example**: Building ModuleRegistry without refactoring backend/app.py to use it = WRONG

**Correct**: Build ModuleRegistry AND refactor backend/app.py in SAME session = RIGHT

---

## ğŸ¯ PRIORITY 2: DEVELOPMENT STANDARDS

### 4. Modular Architecture â­ PROJECT STANDARD

**Structure**:
```
modules/[module-name]/
â”œâ”€â”€ module.json          # Configuration
â”œâ”€â”€ backend/             # Python services
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ service.py
â”œâ”€â”€ frontend/            # UI5 (optional)
â”œâ”€â”€ tests/               # Module tests
â””â”€â”€ docs/                # Module docs
```

**Benefits**: Self-contained, plug-and-play, feature-toggleable

**Reference**: `core/README.md`, [[Modular Architecture]]

---

### 5. API-First Development â­ MANDATORY

**Principle**: Implement business logic as APIs before UI

**Requirements**:
- âœ… Zero UI dependencies
- âœ… Dependency injection
- âœ… Async/Promise-based
- âœ… Works in Node.js, browser, CLI
- âœ… JSDoc documented

**Example**:
```javascript
export class FeatureAPI {
    constructor(storageService) {
        this.storage = storageService; // Injected!
    }
    
    async getData() {
        return await this.storage.load(); // Pure logic
    }
}
```

---

### 6. Comprehensive Testing â­ MANDATORY

**Standards**:
- âœ… 100% API method coverage
- âœ… Tests run in Node.js (not browser)
- âœ… Tests run in < 5 seconds
- âœ… Mock dependencies for isolation
- âœ… Test success AND error scenarios

**UI Testing**:
- âœ… Use jsdom for browser simulation
- âœ… Catch SAP UI5 API misuse
- âœ… Tests run in < 10 seconds

**Reference**: [[Testing Standards]] in knowledge vault

---

### 7. SAP Fiori Compliance â­ MANDATORY

**Critical Rules**:
1. âœ… **Use standard controls first** (InputListItem, not CustomListItem)
2. âœ… **No CSS hacks** (no !important, no custom padding overrides)
3. âœ… **Pure JavaScript preferred** (easier debugging than XML)
4. âœ… **Start simple** (title + one control â†’ incremental complexity)

**Quick Check**:
- Which Fiori control for this purpose?
- Standard control available? Use it!
- Need CSS fix? Wrong control chosen!

**Reference**: [[SAP Fiori Design Standards]], [[InputListItem Control Decision]]

---

## ğŸ¯ PRIORITY 3: OPERATIONAL PRACTICES

### 8. Application Logging

**Purpose**: Primarily for AI assistant troubleshooting

**Log**:
- âœ… API calls, database queries, errors
- âœ… Performance metrics, business decisions
- âŒ Sensitive data, debug statements

**When issues occur**: Check logs FIRST via UI "Logs" button

---

### 9. Git Workflow

**AI Does**:
- âœ… Stage: `git add <files>`
- âœ… Commit: `git commit -m "msg"`
- âœ… Tag milestones: `git tag -a vX.Y-name`

**AI Does NOT**:
- âŒ Push to GitHub (user decides when)
- âŒ Pull changes
- âŒ Remote operations

**Tagging**: Major milestones only (not minor fixes)

---

### 10. Project Tracker

**Update `PROJECT_TRACKER.md` after**:
- âœ… Feature completion
- âœ… Major refactoring
- âœ… Bug fixes
- âœ… Architecture changes

**Format**: Version entry with objectives, work performed, metrics, status

---

## ğŸ“‹ AI ASSISTANT CHECKLIST

**Before implementing features**:

1. âœ… Check knowledge graph
2. âœ… Check knowledge vault docs
3. âœ… **ASK: Should I implement discussed architecture first?** â­ NEW
4. âœ… Create compliance checklist (all 7 requirements)
5. âœ… Estimate FULL time (tests + docs + tracker)
6. âœ… Get user approval
7. âœ… Follow ALL steps
8. âœ… Self-audit before commit

**NO SHORTCUTS**: Implement fewer features correctly, not more features poorly

---

## ğŸ“ Quick Reference

### Fiori UI Development
- Standard controls first
- No CSS hacks
- Pure JavaScript
- Start simple, build incrementally
- Check: [[SAP Fiori Design Standards]]

### Testing
- 100% API coverage
- Node.js tests < 5s
- UI tests < 10s
- Check: [[Testing Standards]]

### Architecture
- Modular structure: `modules/[name]/backend/`
- Feature toggleable
- Self-documented
- Check: [[Modular Architecture]]

### Documentation
- Knowledge vault: `docs/knowledge/`
- Use [[wikilinks]]
- Update INDEX.md
- Check: `docs/knowledge/README.md`

### Git
- Clear commit messages
- AI commits, user pushes
- Tags for milestones only
- Update PROJECT_TRACKER.md

---

## ğŸ“š Key References

**Knowledge Vault** (â­ Start here):
- `docs/knowledge/INDEX.md` - All documentation
- [[SAP Fiori Design Standards]]
- [[Testing Standards]]
- [[Modular Architecture]]
- [[HANA Connection Module]]

**Legacy Docs** (detailed references):
- Fiori: `docs/fiori/SAP_FIORI_DESIGN_GUIDELINES.md`
- HANA: `docs/hana-cloud/` (25+ guides)
- Planning: `docs/planning/` (architecture & features)

---

**Summary**: Follow Priority 1 (essential workflows), then Priority 2 (development standards), then Priority 3 (operational practices). Reference knowledge vault for detailed guidance.