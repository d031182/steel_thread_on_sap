Before execute the tasks, always adhere to the following rules and development guide:

# üß† CRITICAL: KNOWLEDGE GRAPH FIRST POLICY

**MANDATORY MEMORY CHECK BEFORE ANY WORK**

At the START of EVERY session or task, the AI Assistant MUST:

1. ‚úÖ **Query knowledge graph FIRST** - Check what we already know
   ```
   <use_mcp_tool>
   <server_name>github.com/modelcontextprotocol/servers/tree/main/src/memory</server_name>
   <tool_name>search_nodes</tool_name>
   <arguments>{"query": "[relevant search terms]"}</arguments>
   </use_mcp_tool>
   ```

2. ‚úÖ **Review existing entities** - Before investigating or researching
   - Search for relevant topics: HANA, CSN, BDC, feature names, etc.
   - Open related entities to see what's already documented
   - Build on existing knowledge, don't duplicate effort

3. ‚úÖ **Update knowledge at session END** - Store new learnings
   - Create entities for key discoveries
   - Document solutions and decisions
   - Link related concepts

**WHY THIS MATTERS:**
- ‚ùå Without checking: Waste 90 minutes re-investigating known topics
- ‚úÖ With checking: Build on previous work, move faster, avoid duplication
- üß† Knowledge graph = Project memory across sessions

**EXAMPLES:**

Starting investigation:
```javascript
// BAD: Jump into research without checking
"Let me investigate how to get CSN data..."

// GOOD: Check memory first
"Let me first check what we already know about CSN..."
<use_mcp_tool>
  <tool_name>search_nodes</tool_name>
  <arguments>{"query": "CSN HANA"}</arguments>
</use_mcp_tool>
```

**NO EXCEPTIONS**: This is not optional. Check knowledge graph FIRST, always!

### Obsidian Vault Integration

**ALSO check Obsidian vault** for existing knowledge:

**Vault Location**: `C:\Users\D031182\OneDrive - SAP SE\Documents\Obsidian\MyNotesVault\mynotes`

**When to Check**:
1. ‚úÖ At session start, check relevant Obsidian notes
2. ‚úÖ Before investigating new topics (BDC, HANA, CSN, etc.)
3. ‚úÖ User's notes may contain context, decisions, or findings

**Key Obsidian Files to Reference**:
- `BDC MCP Service.md` - BDC and MCP information
- `Data Product Support in SAP HANA Cloud.md` - HANA capabilities
- `Procure-To-Pay (P2P) Data Products.md` - P2P project context
- `SAP HANA Cloud.md` - HANA Cloud details

**Workflow**:
```
Session Start:
1. Check MCP knowledge graph memory
2. Check relevant Obsidian notes
3. Combine knowledge from both sources
4. Then begin investigation/implementation
```

---

# üèóÔ∏è MODULAR ARCHITECTURE ‚≠ê PROJECT STANDARD

**Core Principle**: All backend services live in `modules/[module-name]/backend/`

### Module Structure

```
modules/[module-name]/
‚îú‚îÄ‚îÄ module.json          # Configuration (required)
‚îú‚îÄ‚îÄ backend/            # Python backend services
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py     # Clean exports
‚îÇ   ‚îî‚îÄ‚îÄ service.py      # Business logic
‚îú‚îÄ‚îÄ frontend/           # UI5 frontend (optional)
‚îú‚îÄ‚îÄ tests/              # Module tests
‚îî‚îÄ‚îÄ docs/               # Module docs (optional)
```

### Benefits
- ‚úÖ **Self-contained** - Each module is independent
- ‚úÖ **Plug-and-play** - Add/remove by folder
- ‚úÖ **Feature flags** - Toggle via feature_flags.json
- ‚úÖ **Auto-discovery** - Core infrastructure finds modules
- ‚úÖ **Clean imports** - `from modules.my_module.backend import Service`

### Examples
- `modules/hana_connection/backend/` - HANA connection management
- `modules/data_products/backend/` - Data products service
- `modules/feature-manager/backend/` - Feature management API

### Legacy Pattern (OBSOLETE)
- ‚ùå `backend/services/` - Old centralized approach (removed)
- ‚úÖ Migrated to modular structure

**Reference**: Core infrastructure in `core/README.md`

---

# üí° DEVELOPMENT PHILOSOPHY: DON'T REINVENT THE WHEEL

**Core Principle**: Apply industry best practices and standards rather than creating custom solutions

**Key Tenets**:
1. ‚úÖ **Check standards first** - When proposing new approaches, validate against industry best practices
2. ‚úÖ **Intuition + validation** - Intuitive proposals are good, but verify against existing standards
3. ‚úÖ **Time optimization** - Save time for real new problems, not re-inventing solved patterns
4. ‚úÖ **AI assistant role** - Speak up when industry standards already exist for proposed approaches

**Example Success: Git Tagging Strategy**
- User intuitively proposed conservative tagging (milestones only)
- AI validated against industry standards (Linux Kernel, GitHub, enterprise practices)
- Result: User's approach perfectly matched best practices ‚úÖ
- Outcome: Confidence in approach + time saved

**Application in Practice**:
- When considering new patterns ‚Üí Check if industry standard exists first
- When designing architectures ‚Üí Research proven approaches before proposing custom
- When writing code ‚Üí Use established design patterns (don't create new ones unnecessarily)
- When setting up tools ‚Üí Follow official recommendations and best practices
- When proposing workflows ‚Üí Validate against how major projects do it

**Benefits**:
- ‚è∞ **Time Saved** - No custom solution design needed
- ‚úÖ **Quality Assured** - Battle-tested by thousands of developers
- üìö **Documentation Available** - Rich ecosystem of guides and examples
- ü§ù **Industry Compatible** - Easy onboarding for other developers
- üéØ **Focus on Real Problems** - Spend energy on unique business logic, not infrastructure

**AI Assistant Responsibilities**:
- Research industry standards before proposing custom solutions
- Validate user's intuitive proposals against best practices
- Provide evidence when standards exist (e.g., "Linux Kernel uses...", "GitHub recommends...")
- Explain why standards work and their benefits
- Only propose custom solutions when no standard exists or standard doesn't fit

---

# ‚ö†Ô∏è CRITICAL: AI ASSISTANT ENFORCEMENT POLICY

**MANDATORY COMPLIANCE CHECKPOINT**

Before implementing ANY feature, the AI Assistant MUST:

1. ‚úÖ **Check knowledge graph FIRST** - See "KNOWLEDGE GRAPH FIRST POLICY" above
2. ‚úÖ **Read these guidelines completely** - Do not skip or skim
3. ‚úÖ **Create a compliance checklist** - List all 7 mandatory requirements
4. ‚úÖ **Estimate FULL time** - Include time for tests, docs, tracker updates
5. ‚úÖ **Ask user for approval** - Present the full plan with time estimate
6. ‚úÖ **Follow ALL steps** - Do not skip testing, documentation, or tracker updates
7. ‚úÖ **Self-audit before commit** - Check compliance against all 7 requirements

**NO EXCEPTIONS**: 
- Speed is NOT an excuse to skip requirements
- "Utility features" still need tests and documentation
- User urgency does NOT override quality standards
- If short on time, implement LESS features but implement them RIGHT

**If unable to comply fully**:
- Tell the user: "To follow our development guidelines, this will take X hours including tests and documentation"
- Get explicit permission to proceed with full compliance OR to skip specific requirements
- Document any skipped requirements as technical debt in PROJECT_TRACKER.md

---

# Development Guidelines & Best Practices

**Project**: P2P Data Products Application  
**Purpose**: Standards and rules for feature development  
**Version**: 1.0  
**Last Updated**: January 22, 2026

---

## üéØ Core Development Principles

This document defines the mandatory standards and best practices for developing new features and capabilities in the P2P Data Products application.

---

## 1. API-First Approach ‚≠ê MANDATORY

### Principle
**Always implement business logic as APIs before building UI**

### Requirements

**‚úÖ DO:**
- Design and implement APIs with zero UI dependencies
- Create pure business logic that works in any environment (browser, Node.js, CLI)
- Use dependency injection for external dependencies (storage, network, etc.)
- Return data structures, not DOM elements or UI components
- Make all API methods async (Promise-based)
- Document APIs with JSDoc comments

**‚ùå DON'T:**
- Mix business logic with UI code
- Use `document`, `window`, or browser-specific APIs in business logic
- Hard-code UI frameworks in API layer
- Assume browser environment in core logic

### Example - Correct API-First Pattern

```javascript
/**
 * SQL Execution API - Pure business logic
 * @class
 */
export class SQLExecutionAPI {
    /**
     * @param {StorageService} storageService - Injected dependency
     * @param {HanaConnectionAPI} connectionAPI - Injected dependency
     */
    constructor(storageService, connectionAPI) {
        this.storage = storageService;
        this.connectionAPI = connectionAPI;
    }

    /**
     * Execute SQL query
     * @param {string} instanceId - Instance identifier
     * @param {string} sql - SQL statement
     * @param {Object} options - Execution options
     * @returns {Promise<Object>} Query result
     */
    async executeQuery(instanceId, sql, options = {}) {
        // Pure business logic - no UI coupling
        const result = await this._execute(instanceId, sql, options);
        await this.saveQueryHistory(result);
        return result;
    }
}

// Later: UI consumes the API
import { sqlExecutionAPI } from './js/api/sqlExecutionAPI.js';

button.addEventListener('click', async () => {
    const result = await sqlExecutionAPI.executeQuery(id, sql);
    displayResults(result); // UI layer handles display
});
```

### Benefits Proven
- ‚úÖ **Version 2.2**: 40/40 tests passing without any browser
- ‚úÖ **Reusability**: APIs work in browser, Node.js, CLI tools, servers
- ‚úÖ **Maintainability**: Clear separation of concerns
- ‚úÖ **Quality**: 100% test coverage achieved

---

## 2. Testability Without UI ‚≠ê MANDATORY

### Principle
**All new services and capabilities must be testable in Node.js without any UI**

### Requirements

**Test Suite Standards:**
- ‚úÖ Every API must have unit tests
- ‚úÖ Tests must run in Node.js (not browser)
- ‚úÖ Achieve 100% method coverage
- ‚úÖ Test both success and error scenarios
- ‚úÖ Use mock dependencies for isolation
- ‚úÖ Tests must run in < 5 seconds

### UI Testing Standards ‚≠ê MANDATORY

**Principle**: UI code must have automated tests just like APIs

**Requirements:**
- ‚úÖ Every UI component must have automated tests
- ‚úÖ Tests use jsdom to simulate browser environment
- ‚úÖ Tests verify HTML structure, SAP UI5 usage, API integration
- ‚úÖ Tests catch common SAP UI5 API misuse
- ‚úÖ Tests run without manual intervention
- ‚úÖ Tests complete in < 10 seconds

**UI Test Template:**
```javascript
/**
 * UI Automated Tests for [Feature Name]
 * 
 * Run with: node modules/[module]/tests/ui_automated.test.js
 */

const { JSDOM } = require('jsdom');
const fs = require('fs');
const path = require('path');

class UITestRunner {
    constructor() {
        this.passed = 0;
        this.failed = 0;
    }

    async setup() {
        // Read HTML file
        const htmlPath = path.join(__dirname, '../templates/your-file.html');
        const html = fs.readFileSync(htmlPath, 'utf-8');

        // Create jsdom environment
        this.dom = new JSDOM(html, {
            url: 'http://localhost:5000/your-route',
            runScripts: 'dangerously',
            resources: 'usable',
            beforeParse(window) {
                // Mock fetch API
                window.fetch = async (url, options = {}) => {
                    // Return mock data
                    return { json: async () => ({ success: true, data: {} }) };
                };
            }
        });
        
        this.window = this.dom.window;
    }

    async test(name, fn) {
        try {
            await fn();
            this.passed++;
            console.log(`‚úÖ ${name}`);
        } catch (error) {
            this.failed++;
            console.error(`‚ùå ${name}`);
            console.error(`   ${error.message}`);
        }
    }

    // Test 1: HTML Structure
    await this.test('HTML document loads correctly', () => {
        const doc = this.dom.window.document;
        this.assertNotNull(doc.getElementById('content'));
        this.assertEqual(doc.title, 'Expected Title');
    });

    // Test 2: SAP UI5 Bootstrap
    await this.test('SAP UI5 bootstrap present', () => {
        const bootstrap = this.dom.window.document.getElementById('sap-ui-bootstrap');
        this.assertNotNull(bootstrap);
        this.assertEqual(bootstrap.getAttribute('data-sap-ui-theme'), 'sap_horizon');
    });

    // Test 3: No Invalid SAP UI5 API Usage
    await this.test('No invalid "class" properties in code', () => {
        const html = fs.readFileSync(htmlPath, 'utf-8');
        
        // Check for invalid patterns
        const invalidPattern = /new sap\.[a-z]+\.\w+\({[^}]*class:/;
        this.assertTrue(
            !invalidPattern.test(html),
            'Should not use "class:" property in SAP UI5 constructors'
        );
        
        // Verify correct pattern exists
        this.assertTrue(
            html.includes('addStyleClass'),
            'Should use addStyleClass() method for CSS classes'
        );
    });

    // Test 4: API Response Structure
    await this.test('Mock API returns correct structure', async () => {
        const response = await this.window.fetch('/api/endpoint');
        const data = await response.json();
        this.assertTrue(data.success);
        this.assertNotNull(data.data);
    });

    // Test 5: Feature-Specific Tests
    // Add tests specific to your UI component...
}

// Run tests
(async () => {
    const runner = new UITestRunner();
    await runner.setup();
    const success = await runner.run();
    process.exit(success ? 0 : 1);
})();
```

**What UI Tests Must Cover:**
1. ‚úÖ HTML document structure (title, body, required elements)
2. ‚úÖ SAP UI5 bootstrap configuration (theme, libraries)
3. ‚úÖ **SAP UI5 API compliance** (no invalid properties like `class:`)
4. ‚úÖ API integration (mock fetch, response handling)
5. ‚úÖ Data structure validation (features, configs, etc.)
6. ‚úÖ CSS classes applied correctly (body, containers)
7. ‚úÖ Required scripts and styles present
8. ‚úÖ Feature-specific functionality

**Example Test Suite (Feature Manager):**
```javascript
// Test: No invalid SAP UI5 properties
test('No invalid "class" properties in code', () => {
    const html = fs.readFileSync(htmlPath, 'utf-8');
    
    // Would catch: new sap.m.Page({ class: "..." })
    const invalidPattern = /new sap\.[a-z]+\.\w+\({[^}]*class:/;
    
    assert.false(
        invalidPattern.test(html),
        'Should not use "class:" in SAP UI5 control constructors'
    );
    
    // Verify correct pattern: oPage.addStyleClass("...")
    assert.true(
        html.includes('addStyleClass'),
        'Should use addStyleClass() method for CSS classes'
    );
});
```

**Running UI Tests:**
```bash
# Install jsdom (one time)
npm install --save-dev jsdom

# Run UI tests
node modules/feature-manager/tests/ui_automated.test.js

# Expected output:
# ‚úÖ HTML document loads correctly
# ‚úÖ SAP UI5 bootstrap present
# ‚úÖ No invalid "class" properties in code
# ‚úÖ Mock API returns correct structure
# ... (all tests)
# üéâ All tests passed!
```

**Benefits of UI Testing:**
- üîç **Catches SAP UI5 API misuse** (invalid properties, wrong methods)
- üêõ **Prevents regressions** (tests fail if code breaks)
- ‚è∞ **Saves time** (no manual browser testing needed)
- üìö **Documents expected behavior** (tests serve as spec)
- ‚úÖ **Ensures quality** (same standard as APIs)

**When to Add UI Tests:**
- ‚úÖ When creating new UI components
- ‚úÖ When modifying existing UI code
- ‚úÖ After fixing UI bugs (add test to prevent recurrence)
- ‚úÖ Before major refactoring (ensure behavior preserved)

**UI Testing Checklist:**
- [ ] UI test file created in `tests/ui_automated.test.js`
- [ ] Tests cover HTML structure
- [ ] Tests verify SAP UI5 bootstrap
- [ ] Tests catch invalid API usage (class property, etc.)
- [ ] Tests verify data structure handling
- [ ] All tests passing (100%)
- [ ] Tests run in < 10 seconds
- [ ] Tests documented with comments

**Reference:**
- Example: `modules/feature-manager/tests/ui_automated.test.js`
- Guide: `docs/planning/features/TESTING_IMPROVEMENT_PLAN.md`
- Pitfalls: `docs/fiori/SAP_UI5_COMMON_PITFALLS.md`

**Test File Structure:**
```javascript
/**
 * Unit Tests for [Feature Name] API
 * 
 * Run with: node tests/[feature]API.test.js
 */

import { FeatureAPI } from '../js/api/featureAPI.js';

class TestRunner {
    constructor() {
        this.passed = 0;
        this.failed = 0;
    }
    
    async test(name, fn) {
        try {
            await fn();
            this.passed++;
            console.log(`‚úÖ ${name}`);
        } catch (error) {
            this.failed++;
            console.error(`‚ùå ${name}`);
            console.error(`   ${error.message}`);
        }
    }
    
    // Helper methods...
}

// Run tests
const runner = new TestRunner();
runner.run().then(success => {
    process.exit(success ? 0 : 1);
});
```

**Mock Dependencies:**
```javascript
// Create mock storage for testing
class MockStorage {
    constructor() {
        this.data = new Map();
    }
    
    async save(key, value) {
        this.data.set(key, value);
        return true;
    }
    
    async load(key) {
        return this.data.get(key);
    }
}

// Inject mock in tests
const mockStorage = new MockStorage();
const api = new FeatureAPI(mockStorage);
```

### Test Coverage Requirements

| Component | Minimum Tests | Status |
|-----------|--------------|--------|
| Each API method | 1 test | Required |
| Error scenarios | 1 per error type | Required |
| Edge cases | As needed | Recommended |
| Integration | Optional | Nice to have |

### Current Test Status
- ‚úÖ HANA Connection API: 10/10 tests passing
- ‚úÖ SQL Execution API: 15/15 tests passing
- ‚úÖ Result Formatter API: 15/15 tests passing
- ‚úÖ **Total**: 40/40 tests (100% pass rate)

---

## 3. SAP Fiori Design Guidelines ‚≠ê MANDATORY

### Principle
**All UI must follow official SAP Fiori design guidelines**

### SAP UI5 Development Best Practices ‚≠ê CRITICAL

**When Building SAP UI5 Applications:**

**STEP -1: AVOID COMMON SAP UI5 PITFALLS** ‚≠ê MOST CRITICAL

### Common SAP UI5 Errors and Solutions

#### ‚ùå ERROR: "Assertion failed: ManagedObject.apply: encountered unknown setting 'showProductSwitch'"

**Cause**: Using properties that don't exist in the control

**Example**:
```javascript
// ‚ùå WRONG
new sap.f.ShellBar({
    showProductSwitch: false  // This property doesn't exist!
});
```

**Solution**: Remove the invalid property
```javascript
// ‚úÖ CORRECT
new sap.f.ShellBar({
    showNavButton: false,
    showCopilot: false,
    showSearch: false,
    showNotifications: false
    // No showProductSwitch!
});
```

**How to Fix**:
1. Check SAP UI5 API documentation for the control
2. Remove any properties not listed in the API
3. Search for "sap.f.ShellBar" in SDK to see valid properties

---

#### ‚ùå ERROR: "Font configuration for collection 'SAP-icons-TNT' is not registered"

**Cause**: Using icons from icon libraries that aren't loaded

**Example**:
```javascript
// ‚ùå WRONG - Requires SAP-icons-TNT library
icon: "sap-icon://SAP-icons-TNT/network"
```

**Solution**: Use standard icons OR load the library
```javascript
// ‚úÖ OPTION 1: Use standard icon (recommended)
icon: "sap-icon://cloud"

// ‚úÖ OPTION 2: Load TNT library (if you really need TNT icons)
data-sap-ui-libs="sap.m,sap.f,sap.tnt"
// Then you can use: "sap-icon://SAP-icons-TNT/network"
```

**Standard Icon Alternatives**:
- `sap-icon://SAP-icons-TNT/network` ‚Üí `sap-icon://cloud` or `sap-icon://globe`
- `sap-icon://SAP-icons-TNT/arrow` ‚Üí `sap-icon://arrow-right`
- `sap-icon://SAP-icons-TNT/tool` ‚Üí `sap-icon://wrench`

---

#### ‚ö†Ô∏è WARNING: "Assertion failed: Method 'class' must be called with exactly one class name"

**Cause**: SAP UI5 framework internal assertion (NOT your code)

**When it appears**:
- Opening complex dialogs
- Rendering nested controls
- SAP UI5 debug build validation

**What it means**:
- ‚úÖ **NOT caused by `class:` property in your code**
- ‚úÖ Framework internal validation
- ‚úÖ **HARMLESS** - doesn't break functionality

**How to verify it's not your code**:
```bash
# Search for class: property (should return nothing)
Select-String -Path "your-file.html" -Pattern "new sap\.[a-z]+\.\w+\({[^}]*class:"
```

**What to do**:
1. ‚úÖ Verify no `class:` properties in constructors
2. ‚úÖ Verify using `addStyleClass()` method correctly
3. ‚úÖ If both are correct ‚Üí **ignore the warning**
4. ‚úÖ Document that it's a framework warning, not a bug

**When it IS your code** (would show this error too):
```javascript
// ‚ùå WRONG - Using class: property
new sap.m.Page({
    title: "My Page",
    class: "sapUiContentPadding"  // Don't do this!
});

// ‚úÖ CORRECT - Use addStyleClass()
var oPage = new sap.m.Page({
    title: "My Page"
});
oPage.addStyleClass("sapUiContentPadding");
```

---

#### üîç How to Debug SAP UI5 Errors

**Step 1: Check the error message**
- "unknown setting" ‚Üí Invalid property name
- "not registered" ‚Üí Missing library
- "Method 'class'" ‚Üí Framework internal (usually harmless)

**Step 2: Search SAP UI5 SDK**
- Go to: https://sapui5.hana.ondemand.com/
- Search for the control (e.g., "sap.f.ShellBar")
- Check "Properties" section for valid properties

**Step 3: Verify your code**
```bash
# Check for invalid class: usage
Select-String -Pattern "class:" your-file.html

# Check for TNT icons without library
Select-String -Pattern "SAP-icons-TNT" your-file.html
```

**Step 4: Test the fix**
- Remove invalid properties
- Use standard icons
- Hard refresh browser (Ctrl+F5)

---

**STEP 0: ASK THE RIGHT QUESTION FIRST** ‚≠ê MOST CRITICAL

Before writing any code, always ask:
> **"Which control should be used for this purpose according to Fiori guidelines?"**

**Why This Question Matters**:
- ‚úÖ Multiple controls may technically work, but only ONE is the Fiori-recommended choice
- ‚úÖ Fiori guidelines specify WHEN to use which control for which scenario
- ‚úÖ Using the right control from the start saves hours of CSS fixes and refactoring
- ‚úÖ The right control provides built-in spacing, behavior, and UX patterns

**Process**:
1. ü§î **Define the requirement**: "I need a list with labels and switches"
2. üìö **Check Fiori guidelines**: "What does Fiori recommend for lists with input controls?"
3. ‚úÖ **Find the answer**: "InputListItem is designed for lists with input controls"
4. üíª **Implement correctly**: Use InputListItem (not CustomListItem + CSS hacks)

**Example - Feature Manager**:
```
‚ùå WRONG: "I'll use CustomListItem because it's flexible"
   ‚Üí Result: CSS hacks needed, fighting the framework

‚úÖ RIGHT: "Which control is for lists with input controls?"
   ‚Üí Answer: InputListItem (in Fiori guidelines)
   ‚Üí Result: Built-in spacing, no CSS needed
```

**Where to Find Answers**:
- Fiori Design Guidelines: https://experience.sap.com/fiori-design-web/
- SAP UI5 SDK: https://sapui5.hana.ondemand.com/
- Project docs: `docs/fiori/SAP_FIORI_DESIGN_GUIDELINES.md`

1. **USE STANDARD CONTROLS FIRST** ‚≠ê CRITICAL PRINCIPLE
   - ‚úÖ **Always start with standard SAP UI5 controls** (StandardListItem, InputListItem, etc.)
   - ‚úÖ **Standard controls provide built-in Fiori spacing and behavior**
   - ‚ùå **Avoid CustomListItem, custom HTML, custom CSS unless absolutely necessary**
   - ‚úÖ **Only use custom controls when standard controls cannot accomplish the requirement**
   - ‚úÖ **Rationale**: Standard controls are battle-tested, maintained by SAP, and follow Fiori guidelines automatically
   
   **Example Decision Tree**:
   ```
   Need a list with text and a switch?
   ‚îú‚îÄ Try InputListItem first (standard) ‚úÖ
   ‚îú‚îÄ Does it work? YES ‚Üí Use it!
   ‚îî‚îÄ Does it work? NO ‚Üí Consider CustomListItem (last resort)
   ```

2. **AVOID CSS HACKS** ‚≠ê CRITICAL PRINCIPLE
   - ‚ùå **Never use !important to override SAP UI5 styles**
   - ‚ùå **Don't add custom CSS padding/margins to fix spacing**
   - ‚ùå **Avoid targeting SAP-internal CSS classes** (e.g., `.sapMCustomListItem .sapMHBox`)
   - ‚úÖ **If spacing is wrong, you're using the wrong control**
   - ‚úÖ **CSS hacks are as bad as custom controls - use only as absolute last resort**
   - ‚úÖ **Standard controls provide correct spacing automatically**
   
   **Bad Example** (CSS hack):
   ```css
   /* BAD - Fighting the framework */
   .sapMCustomListItem .sapMHBox.sapUiContentPadding {
       padding: 1rem !important;
   }
   ```
   
   **Good Example** (Use correct control):
   ```javascript
   // GOOD - Use InputListItem (has built-in spacing)
   new sap.m.InputListItem({
       label: "Feature Name",
       content: [new sap.m.Switch()]
   });
   ```

3. **PREFER PURE JAVASCRIPT OVER XML VIEWS** ‚≠ê CRITICAL
   - ‚úÖ **Default to JavaScript instantiation** - Avoid XML views unless specifically required
   - ‚úÖ **User preference**: User prefers JavaScript-only SAP UI5 development
   - ‚úÖ **Reasons**: 
     * More reliable and works immediately
     * **Much easier to debug** - JavaScript debugging in browser is straightforward
     * XML debugging is difficult and opaque ("ugly XML files")
     * Browser DevTools work perfectly with JavaScript
     * Console.log and breakpoints just work
     * Can see actual object instances and properties
   - ‚úÖ **Pattern**: Direct control instantiation (new sap.m.Page, new sap.m.List, etc.)
   - ‚ùå **Avoid**: XML views with MVC unless user explicitly requests them
   
2. **APPROACH TO COMPLEXITY** üéØ
   - ‚úÖ **You CAN start complex** - It's fine to begin with complex components (IconTabBar, forms, etc.)
   - ‚úÖ **When to pivot**: If facing issues and debugging takes too long without finding root cause
   - ‚úÖ **Fallback strategy**: Switch to simple version, test incrementally, identify what works
   - ‚úÖ **Incremental build**: Start minimal (title + one control) ‚Üí add API ‚Üí add controls ‚Üí add complexity
   - ‚úÖ **Pattern**: Complex attempt ‚Üí issues ‚Üí simple version ‚Üí incremental build ‚Üí working solution
   - ‚úÖ **Not wrong to start complex** - Only switch to incremental if debugging becomes time-consuming
   
3. **Debugging SAP UI5 UX Issues:**
   
   **Common Problem**: Content not visible, narrow vertical panel, white space
   
   **Root Causes**:
   - Complex XML views with MVC structure may not render
   - IconTabBar or nested layouts failing silently
   - Data binding issues (wrong path, nested structures)
   - CSS height/overflow conflicts
   
   **Solution Approach** (Proven Jan 24, 2026):
   ```javascript
   // STEP 1: Create simple version FIRST
   // File: configurator_test.html
   
   // Direct JavaScript instantiation (no XML)
   var oPage = new sap.m.Page({
       title: "Feature Manager",
       content: [
           new sap.m.MessageStrip({
               text: "Loading...",
               type: "Information"
           })
       ]
   });
   
   // STEP 2: Add API call
   fetch("/api/features")
       .then(response => response.json())
       .then(data => {
           console.log("API Response:", data);
           // Add content programmatically
       });
   
   // STEP 3: Once working, gradually add complexity
   // - Add lists
   // - Add switches
   // - Add categories
   // - Add IconTabBar (last!)
   ```
   
   **Debugging Checklist**:
   - [ ] Does simple JavaScript version work?
   - [ ] Is API returning data? (check console.log)
   - [ ] Is data structure correct? (nested features.features?)
   - [ ] Are controls rendering? (check browser inspector)
   - [ ] Is page height set correctly? (html, body, #content)
   
   **DO NOT**:
   - ‚ùå Start with complex XML views with IconTabBar
   - ‚ùå Add multiple features before testing basic rendering
   - ‚ùå Assume MVC structure will work without testing
   - ‚ùå Skip console.log debugging of API responses
   
   **Key Learning (Jan 24, 2026)**:
   - Simple JavaScript version: ‚úÖ Worked immediately
   - Complex XML with IconTabBar: ‚ùå White space, no content
   - Solution: Build up from simple ‚Üí complex incrementally

### Requirements

**Framework:**
- ‚úÖ Use SAP UI5 / OpenUI5 framework
- ‚úÖ Use official SAP UI5 controls (sap.m, sap.f, sap.ui.layout)
- ‚úÖ Use SAP Horizon theme (`sap_horizon`)
- ‚ùå DO NOT create custom HTML/CSS components when UI5 controls exist
- ‚úÖ **START SIMPLE** - Pure JavaScript before XML views
- ‚úÖ **TEST INCREMENTALLY** - Add one component at a time

**Design Principles (SAP Fiori 5):**
1. **Role-Based** - Clear purpose and user roles
2. **Responsive** - Mobile, tablet, desktop support
3. **Simple** - Minimal cognitive load
4. **Coherent** - Consistent patterns
5. **Delightful** - Professional appearance

**Spacing System:**
```javascript
// Use official SAP UI5 spacing classes
sapUiContentPadding      // 1rem (16px) - Content areas
sapUiSmallMargin         // 0.5rem (8px) - Small gaps
sapUiMediumMargin        // 1rem (16px) - Medium gaps
sapUiLargeMargin         // 2rem (32px) - Large gaps
sapUiTinyMargin          // 0.25rem (4px) - Fine adjustments
sapUiResponsiveMargin    // Responsive margins
```

**Color Palette:**
```javascript
// SAP Horizon theme colors
Primary Blue:   #0070f2
Success Green:  #107e3e
Error Red:      #b00
Warning Orange: #e9730c
Shell Dark:     #354a5f
Background:     #f5f6f7
```

**Component Selection:**
- Tables: `sap.m.Table` or `sap.ui.table.Table`
- Forms: `sap.ui.layout.form.Form`
- Navigation: `sap.m.IconTabBar`
- Headers: `sap.f.ShellBar`
- Dialogs: `sap.m.Dialog`
- Lists: `sap.m.List`

**Reference Documentation:**
- Main Guide: https://experience.sap.com/fiori-design-web/
- UI5 Controls: https://sapui5.hana.ondemand.com/
- Design Guidelines: `docs/fiori/SAP_FIORI_DESIGN_GUIDELINES.md`

### Quality Checklist
- [ ] Uses SAP UI5 framework
- [ ] Uses Horizon theme
- [ ] Uses standard controls only
- [ ] Follows spacing system
- [ ] Responsive design tested
- [ ] Accessible (keyboard, screen reader)
- [ ] No custom HTML/CSS (unless necessary)

---

## 4. Feature Documentation ‚≠ê MANDATORY

### Principle
**Each new feature must have comprehensive documentation in a dedicated file**

### Requirements

**Documentation File Structure:**

```markdown
# [Feature Name] - Implementation Guide

**Feature**: [Name]
**Version**: 1.0
**Date**: [Date]
**Status**: [Planning / In Progress / Complete]

---

## Overview

Brief description of the feature and its purpose.

## Requirements

What the feature must accomplish:
1. Requirement 1
2. Requirement 2
3. ...

## Architecture

### API Layer
- API file: `js/api/[feature]API.js`
- Methods: [list methods]
- Dependencies: [list dependencies]

### Service Layer (if needed)
- Service files
- Utilities

### UI Layer
- UI components
- Fiori controls used
- Integration points

## Implementation Plan

**Phase 1: API Development** (X hours)
- [ ] Task 1
- [ ] Task 2
- [ ] ...

**Phase 2: Testing** (X hours)
- [ ] Task 1
- [ ] Task 2

**Phase 3: UI Integration** (X hours)
- [ ] Task 1
- [ ] Task 2

## API Reference

### Method: methodName()
**Purpose**: What it does
**Parameters**: List parameters
**Returns**: Return type and structure
**Example**:
```javascript
const result = await api.methodName(params);
```

## Test Coverage

- [ ] Unit tests created
- [ ] Tests passing: X/X
- [ ] Coverage: 100%

## UI Components

List of UI5 controls used and their purpose.

## Files Created

1. `path/to/file1.js` - Description
2. `path/to/file2.js` - Description
3. ...

## Usage Examples

### Basic Usage
```javascript
// Code example
```

### Advanced Usage
```javascript
// Code example
```

## Status

Current status and next steps.
```

### Example Documentation Files
- ‚úÖ `SQL_EXECUTION_ENHANCEMENT_PLAN.md` - Planning document
- ‚úÖ `SQL_EXECUTION_API_SUMMARY.md` - Complete summary
- ‚úÖ `HANA_CONNECTION_IMPLEMENTATION_SUMMARY.md` - API summary

### Documentation Locations
- **Planning**: Project root or `docs/` folder
- **API Docs**: Embedded JSDoc comments
- **User Guides**: `docs/` folder
- **Reference**: `README.md` or dedicated guides

---

## 5. Application Logging ‚≠ê MANDATORY

### Principle
**Use application logging for troubleshooting, workflow understanding, and issue resolution**

### Purpose of Application Logging

The application logging system serves three critical purposes:

#### 1. **Troubleshooting Tool**
- ‚úÖ Identify issues when they occur
- ‚úÖ Understand the sequence of events leading to problems
- ‚úÖ Debug production issues without code changes
- ‚úÖ Monitor system health in real-time

#### 2. **Workflow Understanding**
- ‚úÖ Log essential activities to track application flow
- ‚úÖ Document key decision points and data transformations
- ‚úÖ Show timing and performance metrics
- ‚úÖ Trace requests through the system

#### 3. **AI Assistant Tool** ‚≠ê PRIMARY PURPOSE
- ‚úÖ **The log is PRIMARILY for the AI assistant to consume**
- ‚úÖ AI uses logs to understand what's happening in the application
- ‚úÖ AI analyzes logs to identify root causes of issues
- ‚úÖ AI references logs when helping developers resolve problems
- ‚úÖ Logs enable AI to provide accurate, context-aware assistance

### What to Log

**Essential Activities** ‚úÖ:
```python
# Backend (Flask)
logger.info("Loaded 5 data products from HANA")
logger.info("Query executed successfully: 100 rows, 1644.97ms")
logger.warning("Limiting to first 10 of 120 columns for table SalesOrder")
logger.error("Failed to connect to HANA: Connection timeout")
```

**DO Log:**
- ‚úÖ API endpoint calls (method, path, user)
- ‚úÖ Database queries (SQL, execution time, row count)
- ‚úÖ External service calls (URL, response time, status)
- ‚úÖ Business logic decisions (why path A vs path B)
- ‚úÖ Error conditions (what failed, why, context)
- ‚úÖ Performance metrics (execution times, counts)
- ‚úÖ Configuration changes (what changed, who, when)
- ‚úÖ Authentication/authorization events
- ‚úÖ Data transformations (input ‚Üí process ‚Üí output)

**DON'T Log:**
- ‚ùå Sensitive data (passwords, tokens, PII)
- ‚ùå Full request/response payloads (too verbose)
- ‚ùå Every single line of code execution
- ‚ùå Redundant information
- ‚ùå Debug statements in production

### Log Levels

Use appropriate log levels:

```python
# INFO - Normal operations, key milestones
logger.info("Processing order #12345")
logger.info("Email sent successfully to user@example.com")

# WARNING - Something unexpected but not critical
logger.warning("Cache miss for key 'product_123', fetching from database")
logger.warning("API rate limit approaching: 950/1000 requests")

# ERROR - Something failed but application continues
logger.error("Failed to send email: SMTP connection refused")
logger.error("Database query timeout after 30 seconds")

# CRITICAL - Severe issue requiring immediate attention
logger.critical("Database connection pool exhausted")
logger.critical("Out of memory error")
```

### Log Format Standards

**Backend (Python):**
```python
# Include context in every log entry
logger.info(f"Query executed successfully: {row_count} rows, {execution_time:.2f}ms")
logger.warning(f"Limiting to first {limit} of {total} columns for table {table_name}")
logger.error(f"Failed to connect to {host}:{port}: {error_message}")
```

**Frontend (JavaScript):**
```javascript
// Use console for development, API logging for production
console.log(`[DataProductsAPI] Fetched ${count} products`);
console.warn(`[SQLExecutionAPI] Query took ${time}ms (slow)`);
console.error(`[HanaConnectionAPI] Connection failed:`, error);
```

### AI Assistant Usage

**How AI Uses Logs:**

1. **Diagnosing Issues:**
   ```
   User: "The query is failing"
   
   AI: *Checks application logs*
       ‚Üí Sees: "ERROR: Query timeout after 30 seconds"
       ‚Üí Identifies: Database performance issue
       ‚Üí Suggests: Optimize query or increase timeout
   ```

2. **Understanding Workflows:**
   ```
   User: "Why is the table limiting columns?"
   
   AI: *Checks application logs*
       ‚Üí Sees: "WARNING: Limiting to first 10 of 120 columns"
       ‚Üí Explains: Performance optimization for readability
       ‚Üí Shows: Where limit is configured
   ```

3. **Root Cause Analysis:**
   ```
   User: "Data products aren't loading"
   
   AI: *Analyzes log sequence*
       ‚Üí Sees: "INFO: Connecting to HANA..."
       ‚Üí Sees: "ERROR: Connection refused"
       ‚Üí Identifies: HANA server unavailable
       ‚Üí Recommends: Check network, verify server status
   ```

### Mandatory Log Analysis Workflow ‚≠ê CRITICAL

**When User Reports an Issue:**

1. **ALWAYS Check Application Logs FIRST**
   ```
   Step 1: Ask user to access logs via "Logs" button in app
   Step 2: Request user to share recent ERROR and WARNING entries
   Step 3: Analyze log sequence to understand what happened
   Step 4: Identify root cause from error context
   Step 5: Provide solution based on log evidence
   ```

2. **Log Categories to Analyze:**
   - `[HANA]` - All HANA connection and query errors
   - `[CLIENT]` - All browser JavaScript errors
   - `[API]` - All backend API endpoint errors
   - Request/response logs - Track request flow
   - Performance logs - Identify bottlenecks

3. **Root Cause Identification:**
   ```
   Error Pattern                    ‚Üí Root Cause
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   [HANA] Connection refused        ‚Üí IP not in allowlist
   [HANA] Error code: 258           ‚Üí Invalid credentials
   [HANA] Error code: 259           ‚Üí Table/view not found
   [HANA] Error code: 10              ‚Üí Insufficient privileges
   [CLIENT] TypeError: undefined    ‚Üí Frontend logic error
   [CLIENT] Failed to fetch         ‚Üí Backend API down/unreachable
   ```

4. **Example Analysis Session:**
   ```
   User: "I'm getting an error when loading data products"
   
   AI Response:
   1. "Let me check the application logs first"
   2. "Please click the 'Logs' button in the top right"
   3. "Share any recent ERROR entries you see"
   
   User shares log:
   [HANA] ‚úó Connection failed to hostname:443
   [HANA] Error code: -10709
   [HANA] Error message: Connection refused
   
   AI Analysis:
   - Root Cause: IP address not in HANA Cloud allowlist
   - Solution: Add current IP to allowlist via SAP BTP cockpit
   - Prevention: Document IP in configuration guide
   ```

5. **Do NOT Skip Log Analysis:**
   - ‚ùå DON'T guess the problem without checking logs
   - ‚ùå DON'T ask user to describe error when logs exist
   - ‚ùå DON'T propose solutions without log evidence
   - ‚úÖ DO check logs first, diagnose accurately, solve confidently

### Implementation

**Backend Setup:**
```python
# Flask app.py
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# In-memory log storage for UI access
class MemoryLogHandler(logging.Handler):
    def __init__(self, max_logs=100):
        super().__init__()
        self.logs = []
        self.max_logs = max_logs
    
    def emit(self, record):
        self.logs.append({
            'timestamp': datetime.now().isoformat(),
            'level': record.levelname,
            'message': self.format(record)
        })
        # Keep only last max_logs
        if len(self.logs) > self.max_logs:
            self.logs.pop(0)

# Add handler
memory_handler = MemoryLogHandler(max_logs=100)
logger.addHandler(memory_handler)

# API endpoint for logs
@app.route('/api/logs')
def get_logs():
    return jsonify({
        'success': True,
        'logs': memory_handler.logs
    })
```

**Frontend Integration:**
```javascript
// Access logs via API
const logViewerAPI = new LogViewerAPI();
const result = await logViewerAPI.getLogs({ limit: 100 });
console.log('Application logs:', result.logs);
```

### Log Viewer UI

**Location**: Top-right "Logs" button in Fiori app

**Features**:
- ‚úÖ Real-time log viewing
- ‚úÖ Filter by level (INFO, WARNING, ERROR)
- ‚úÖ Color-coded entries
- ‚úÖ Timestamps
- ‚úÖ Refresh capability
- ‚úÖ Clear logs function

**Usage**:
```
1. Click "Logs" button (top right)
2. View application activity
3. Filter by log level if needed
4. Share logs with AI for troubleshooting
```

### Best Practices

**1. Be Specific:**
```python
# BAD
logger.info("Processing data")

# GOOD
logger.info(f"Processing 1,234 orders from 2024-01-01 to 2024-01-31")
```

**2. Include Context:**
```python
# BAD
logger.error("Query failed")

# GOOD
logger.error(f"Query failed for table '{table_name}': {error_details}")
```

**3. Log at Right Level:**
```python
# User successfully logged in ‚Üí INFO
logger.info(f"User '{username}' logged in successfully")

# User login failed ‚Üí WARNING (might be wrong password)
logger.warning(f"Failed login attempt for user '{username}'")

# Authentication system crashed ‚Üí ERROR
logger.error(f"Authentication service unavailable: {error}")
```

**4. Use Structured Data:**
```python
# Include metrics
logger.info(f"API response: {status_code}, {response_time}ms, {bytes_sent} bytes")

# Include IDs for tracing
logger.info(f"Order #{order_id} processed by user #{user_id}")
```

### Benefits

**For Developers:**
- üîç Quick issue identification
- üìä Performance insights
- üêõ Faster debugging
- üìà System health monitoring

**For AI Assistant:**
- ü§ñ Accurate problem diagnosis
- üí° Context-aware suggestions
- üéØ Root cause identification
- üìö Application behavior learning

**For Users:**
- ‚úÖ Faster issue resolution
- üì± Real-time system visibility
- üõ°Ô∏è Proactive problem detection
- üìû Better support experience

---

## 6. Version Control with Git ‚≠ê MANDATORY

### Principle
**All code changes must be committed to Git with meaningful commit messages**

### Git Workflow

**Repository Details:**
- **Remote**: https://github.com/d031182/steel_thread_on_sap
- **Branch**: main
- **Workflow**: Feature-based commits with clear messages

### Commit Message Standards

**Format:**
```
[Category] Brief description (max 72 chars)

Optional detailed explanation:
- What was changed
- Why it was changed
- Impact of the change
```

**Categories:**
- `[Feature]` - New functionality
- `[Fix]` - Bug fixes
- `[Refactor]` - Code improvements without behavior change
- `[Docs]` - Documentation updates
- `[Test]` - Test additions or modifications
- `[Config]` - Configuration changes
- `[Chore]` - Maintenance tasks

**Examples:**
```bash
git commit -m "[Feature] Add SQLite persistent logging system

- Implemented SQLiteLogHandler with 2-day retention
- Added automatic cleanup every 6 hours
- Created log viewer API with 13 methods
- Added 15 unit tests (100% passing)"

git commit -m "[Fix] Resolve connection timeout in HANA API

- Increased timeout from 10s to 30s
- Added retry logic with exponential backoff
- Improved error messages"

git commit -m "[Docs] Update HANA Cloud setup guide

- Added BDC-specific instructions
- Included privilege grant examples
- Added troubleshooting section"
```

### Daily Git Workflow

**1. Before Starting Work:**
```bash
# Ensure you're on main branch
git checkout main

# Pull latest changes
git pull origin main

# Check status
git status
```

**2. During Development:**
```bash
# Check which files changed
git status

# View changes
git diff

# Stage specific files
git add path/to/file1.js path/to/file2.js

# Or stage all changes
git add .

# Commit with message
git commit -m "[Feature] Your clear commit message"
```

**3. After Completing Feature:**
```bash
# DO NOT push automatically - wait for user instruction
# User will decide when to push
```

### AI Assistant Git Control Policy ‚≠ê IMPORTANT

**What AI Assistant Will Do:**
- ‚úÖ Stage files: `git add <files>`
- ‚úÖ Commit changes: `git commit -m "message"`
- ‚úÖ Create tags: `git tag -a <tag> -m "message"`

**What AI Assistant Will NOT Do:**
- ‚ùå Push to GitHub: `git push origin main`
- ‚ùå Push tags: `git push origin --tags`
- ‚ùå Pull changes: `git pull origin main`
- ‚ùå Any remote operations

**Why:**
- User maintains full control over what goes to GitHub
- User can review commits before pushing
- User decides timing of pushes
- User manages branches and remote operations

**When AI Can Push:**
- ‚úÖ ONLY when user explicitly says "push to git" or "push to GitHub"
- ‚úÖ ONLY when user gives clear permission

**User Controls:**
```bash
# User runs these commands when ready
git push origin main          # Push commits
git push origin --tags        # Push tags
git pull origin main          # Pull updates
```

### What to Commit

**‚úÖ DO Commit:**
- Source code files (.js, .py, .html, .css)
- Configuration files (.json, .yml, .md)
- Documentation files (.md, .txt)
- Test files (.test.js)
- SQL scripts (.sql)
- Build configurations
- README and guides

**‚ùå DON'T Commit:**
- Sensitive data (passwords, tokens, API keys)
- Log files (*.log, logs/)
- Database files (*.db, *.sqlite)
- Environment files (.env, default-env.json)
- Dependencies (node_modules/, venv/)
- IDE settings (.vscode/, .idea/)
- OS files (.DS_Store, Thumbs.db)
- Build artifacts (dist/, build/)

**Note**: The `.gitignore` file handles most exclusions automatically.

### Backup and Rollback

**Git Replaces Manual Backups:**
- ‚úÖ No need to create backup files (e.g., `file.old`, `file.backup`)
- ‚úÖ No need to archive directories
- ‚úÖ Git history provides complete backup
- ‚úÖ Can rollback to any previous commit

**Rollback Strategies:**

**1. Undo Last Commit (keep changes):**
```bash
git reset --soft HEAD~1
```

**2. Undo Last Commit (discard changes):**
```bash
git reset --hard HEAD~1
```

**3. Revert Specific Commit:**
```bash
git revert <commit-hash>
```

**4. View Commit History:**
```bash
git log --oneline
git log --graph --oneline --all
```

**5. Restore Specific File:**
```bash
# From last commit
git checkout HEAD -- path/to/file

# From specific commit
git checkout <commit-hash> -- path/to/file
```

**6. Create Rollback Point (Tag):**
```bash
# Create tag for important milestones
git tag -a v1.0-sqlite-logging -m "SQLite logging complete"

# Push tag to GitHub
git push origin v1.0-sqlite-logging

# List all tags
git tag -l
```

### Best Practices

**1. Commit Frequently:**
- Commit after each logical change
- Don't wait until end of day
- Small commits are easier to review

**2. Write Clear Messages:**
- Explain what and why, not how
- Use present tense ("Add feature" not "Added feature")
- Reference issue numbers if applicable

**3. Review Before Committing:**
```bash
# Review what you're committing
git diff --staged

# Check for sensitive data
git diff | grep -i password
git diff | grep -i token
```

**4. Keep History Clean:**
- Don't commit commented-out code (delete it)
- Don't commit debug statements
- Don't commit TODO comments without context

**5. Push Regularly:**
- Push at least once per day
- Push after completing features
- Ensures backup to GitHub

### Common Git Commands

```bash
# Status and information
git status              # Check current status
git log                 # View commit history
git diff                # See uncommitted changes
git diff --staged       # See staged changes

# Basic workflow
git add <files>         # Stage files
git commit -m "msg"     # Commit with message
git push origin main    # Push to GitHub
git pull origin main    # Pull from GitHub

# Branching (optional, for experiments)
git branch feature-xyz  # Create branch
git checkout feature-xyz # Switch to branch
git merge feature-xyz   # Merge branch to main

# Undo operations
git reset HEAD <file>   # Unstage file
git checkout -- <file>  # Discard changes
git revert <commit>     # Revert commit
```

### Git Tagging Strategy ‚≠ê MANDATORY

**Purpose**: Create consistent, meaningful rollback points and version milestones

### Tagging Policy

**Tags are for SIGNIFICANT milestones and rollback points ONLY**

**Create a tag when:**
1. ‚úÖ Completing a MAJOR feature (e.g., entire module, major refactoring)
2. ‚úÖ Before risky refactoring or architectural changes (safety checkpoint)
3. ‚úÖ Reaching production-ready milestones (e.g., v1.0, v2.0)
4. ‚úÖ When user explicitly requests a checkpoint
5. ‚úÖ End of development phase (e.g., folder reorganization complete)

**DO NOT create tags for:**
- ‚ùå Minor bug fixes
- ‚ùå Small feature additions
- ‚ùå Documentation updates
- ‚ùå Regular commits
- ‚ùå Work in progress

**Guideline**: If you wouldn't want to rollback to this exact point, don't tag it.

**Tag Naming Convention:**

The project uses a **dual-tagging system** for clarity:

1. **Version Numbers** (vX.Y format):
   ```bash
   v0.1  # Initial foundation
   v0.2  # Major infrastructure update
   v0.3  # Feature additions
   v0.9  # Near completion of phase
   v1.0  # Production release
   ```
   - **X (major)**: Increments for major milestones (0.1 ‚Üí 1.0 ‚Üí 2.0)
   - **Y (minor)**: Increments for feature additions (0.1 ‚Üí 0.2 ‚Üí 0.3)
   - Start at v0.1, increment to v0.9, then jump to v1.0 for production

2. **Descriptive Tags** (vX.Y-description format):
   ```bash
   v0.9-folder-reorganization
   v0.8-modular-architecture-foundation
   v3.4-debug-mode-complete
   v3.3-production
   ```
   - Use kebab-case for multi-word descriptions
   - Be specific about what the tag represents
   - Include feature name or milestone achieved

### Tag Creation Standards

**Format:**
```bash
# Both version and descriptive tag
git tag -a vX.Y-feature-name -m "Version X.Y - Feature description

- Key achievement 1
- Key achievement 2
- Status indicator
- Commit reference (optional)"
```

**Examples:**
```bash
# Major feature completion
git tag -a v0.9-folder-reorganization -m "Version 0.9 - Folder reorganization complete
- Root directory cleaned: 38 ‚Üí 9 files (76% reduction)
- Created organized structure: docs/planning/, sql/hana/users/, scripts/python/, tests/
- Moved 30 files to proper locations
- Professional enterprise-grade structure"

# Before risky changes
git tag -a v0.8-before-refactor -m "Version 0.8 - Stable state before backend refactor
- All tests passing
- Documentation complete
- Safe rollback point"

# Milestone achievement
git tag -a v1.0-production -m "Version 1.0 - Production Release
- All features complete
- Full test coverage
- Documentation complete
- Ready for deployment"
```

### Tagging Workflow

**After Completing Work:**
```bash
# 1. Commit all changes
git add .
git commit -m "[Feature] Complete feature implementation"

# 2. Update PROJECT_TRACKER.md
git add PROJECT_TRACKER.md
git commit -m "[Docs] Update tracker with feature completion"

# 3. Create version tag
git tag -a v0.X-feature-name -m "Version 0.X - Feature description
- Details
- Achievements
- Status"

# 4. Push everything (when user approves)
git push origin main --tags
```

### Version Number Guidelines

**Current Status** (as of Jan 24, 2026):
- Latest: v0.9-folder-reorganization
- Next: v1.0 (when ready for production) OR v0.10 (more features needed)

**When to Increment:**

| Current | Next | Reason |
|---------|------|--------|
| v0.9 | v1.0 | Production ready, all features complete |
| v0.9 | v0.10 | More dev features needed before production |
| v1.0 | v1.1 | Minor feature addition (backward compatible) |
| v1.0 | v2.0 | Major update or breaking change |

**Decision Rule:**
- Use v0.X for development phases (0.1 ‚Üí 0.9)
- Jump to v1.0 for first production release
- Use v1.X for production updates
- Use v2.0, v3.0 for major versions

### Tag Management

**List all tags:**
```bash
git tag -l                    # All tags
git tag -l "v0.*"            # Filter by pattern
git show v0.9-folder-reorganization  # Show tag details
```

**Delete a tag (if mistake):**
```bash
# Delete locally
git tag -d v0.9-wrong-name

# Delete from GitHub (BE CAREFUL!)
git push origin --delete v0.9-wrong-name
```

**Checkout a tag (view code at that point):**
```bash
git checkout v0.9-folder-reorganization   # Read-only view
git checkout main                         # Return to latest
```

### Integration with Project Tracker

**Workflow:**
1. ‚úÖ Implement feature
2. ‚úÖ Write tests and documentation
3. ‚úÖ Commit to Git with clear message
4. ‚úÖ Update PROJECT_TRACKER.md
5. ‚úÖ Commit tracker update
6. ‚úÖ Create version tag ‚≠ê NEW
7. ‚úÖ Push all changes to GitHub (with tags)

**Complete Example:**
```bash
# After implementing feature
git add js/api/newFeature.js tests/newFeature.test.js
git commit -m "[Feature] Add new feature API with tests"

# Update tracker
git add PROJECT_TRACKER.md
git commit -m "[Docs] Update tracker with new feature details"

# Create version tag
git tag -a v0.10-new-feature -m "Version 0.10 - New feature complete
- Feature implemented with tests
- Documentation updated
- Ready for next phase"

# Push everything (when user approves)
git push origin main --tags
```

### Tag Documentation

**In PROJECT_TRACKER.md**, maintain a tags section:

```markdown
## üè∑Ô∏è Git Tags & Milestones

### Latest Tags
- `v0.9-folder-reorganization` ‚≠ê LATEST (Jan 24, 2026)
- `v0.8-modular-architecture` (Jan 24, 2026)
- `v3.4-debug-mode-complete` (Jan 23, 2026)

### Tag History
| Tag | Date | Description |
|-----|------|-------------|
| v0.9-folder-reorganization | 2026-01-24 | Folder structure cleaned |
| v0.8-modular-architecture | 2026-01-24 | Core infrastructure |
```

### Benefits of Consistent Tagging

1. ‚úÖ **Easy Rollback** - Return to any stable point
2. ‚úÖ **Clear History** - See project evolution at a glance
3. ‚úÖ **Safe Experimentation** - Tag before risky changes
4. ‚úÖ **Version Tracking** - Know exactly what's in each version
5. ‚úÖ **Documentation** - Tags serve as project milestones
6. ‚úÖ **Collaboration** - Team knows stable points to build from

### AI Assistant Tagging Responsibility

**AI MUST create tags:**
- After major feature completion
- After folder reorganization or refactoring
- When user completes a milestone
- Before risky architectural changes

**Tag format reminder:**
```bash
git tag -a vX.Y-kebab-case-description -m "Version X.Y - Description
- Achievement 1
- Achievement 2"
```

---

## 7. Project Tracker Updates ‚≠ê MANDATORY

### Principle
**Always update PROJECT_TRACKER.md when completing features**

### Purpose of Project Tracker

‚≠ê **SINGLE SOURCE OF TRUTH**: Always use `PROJECT_TRACKER.md` (NOT `PROJECT_TRACKER_REFACTORED.md`)

The `PROJECT_TRACKER.md` serves as the **complete historical record** of all project work:

**Key Purposes:**
1. **Historical Documentation** - Complete timeline of all development work
2. **Knowledge Preservation** - Captures decisions, problems solved, and solutions
3. **Progress Tracking** - Shows evolution from initial concept to current state
4. **Onboarding Tool** - New developers can understand project history
5. **Reference Guide** - Find how previous features were implemented
6. **Decision Log** - Documents why choices were made
7. **Metrics Record** - Tracks development time, code changes, test coverage
8. **Success Stories** - Shows proven patterns and working examples

**What Gets Tracked:**
- ‚úÖ Feature implementations (new capabilities)
- ‚úÖ Bug fixes (production issues resolved)
- ‚úÖ Architecture changes (refactoring, migrations)
- ‚úÖ Documentation updates (major docs created)
- ‚úÖ Performance improvements (optimizations)
- ‚úÖ Testing milestones (test coverage achievements)
- ‚úÖ User feedback (requests and resolutions)

**Benefits:**
- **For AI Assistant**: Maintains context across sessions, learns from past work
- **For Developers**: Understand project evolution and proven patterns
- **For Users**: See what's been delivered and what's coming
- **For Maintenance**: Quick reference for how features work
- **For Quality**: Track that guidelines are being followed

### Requirements

**When to Update:**
- ‚úÖ After completing planning phase
- ‚úÖ After implementing APIs
- ‚úÖ After completing tests
- ‚úÖ After UI integration
- ‚úÖ After final verification

**Version Entry Template:**

```markdown
### Version X.X - [Feature Name] (YYYY-MM-DD, HH:MM AM/PM)

**Objective**: Brief description of what was accomplished

**User Requirements**:
1. Requirement 1
2. Requirement 2
3. ...

**Work Performed**:

1. ‚úÖ **[Task Category 1]**
   - Details
   - Metrics
   - Status

2. ‚úÖ **[Task Category 2]**
   - Details
   - Metrics
   - Status

**[Feature] Capabilities**:

```javascript
// Code examples showing key features
```

**Architecture Benefits**:

Key improvements and patterns applied.

**Progress Metrics**:

| Metric | Value | Status |
|--------|-------|--------|
| Metric 1 | Value | Status |
| Metric 2 | Value | Status |

**Files Created**:
- ‚úÖ `path/to/file1` - Description
- ‚úÖ `path/to/file2` - Description

**Status**: ‚úÖ **COMPLETED** - [Summary]

---
```

### Memory Tracker Updates

After completing a significant feature, also update the memory tracker:

```javascript
// Use MCP memory tool to store knowledge
<use_mcp_tool>
<server_name>github.com/modelcontextprotocol/servers/tree/main/src/memory</server_name>
<tool_name>create_entities</tool_name>
<arguments>
{
  "entities": [
    {
      "name": "Feature_Name",
      "entityType": "api_component",
      "observations": [
        "Key fact 1",
        "Key fact 2",
        "..."
      ]
    }
  ]
}
</arguments>
</use_mcp_tool>
```

---

## üìã Feature Development Workflow

### Complete Workflow Checklist

**Phase 1: Planning** (1-2 hours)
- [ ] Understand user requirements
- [ ] Research existing patterns
- [ ] Design API architecture
- [ ] Plan UI components
- [ ] Create implementation plan document
- [ ] Estimate time and effort

**Phase 2: API Development** (2-4 hours)
- [ ] Create API file in `js/api/`
- [ ] Implement business logic methods
- [ ] Add JSDoc comments
- [ ] Use dependency injection
- [ ] Handle errors properly
- [ ] Ensure zero UI dependencies

**Phase 3: Testing** (1-2 hours)
- [ ] Create test file in `tests/`
- [ ] Write unit tests (100% method coverage)
- [ ] Test success scenarios
- [ ] Test error scenarios
- [ ] Run tests in Node.js
- [ ] Verify all tests pass

**Phase 4: UI Integration** (2-4 hours)
- [ ] Select appropriate SAP UI5 controls
- [ ] Follow Fiori spacing system
- [ ] Use Horizon theme
- [ ] Wire APIs to UI
- [ ] Test responsive design
- [ ] Verify accessibility

**Phase 5: Documentation** (1 hour)
- [ ] Create feature documentation file
- [ ] Update PROJECT_TRACKER_REFACTORED.md
- [ ] Update memory tracker
- [ ] Update README if needed
- [ ] Add usage examples

**Phase 6: Verification** (30 minutes)
- [ ] Run all tests
- [ ] Test in browser
- [ ] Verify Fiori compliance
- [ ] Check responsive design
- [ ] User acceptance testing

---

## üéØ Quality Standards

### Code Quality
- ‚úÖ Clean, readable code
- ‚úÖ Consistent naming conventions
- ‚úÖ Proper error handling
- ‚úÖ No console.log in production code
- ‚úÖ JSDoc comments on all public methods
- ‚úÖ File size < 1000 lines (split if larger)

### Performance Standards
- ‚úÖ API methods < 100ms response time
- ‚úÖ Test execution < 5 seconds total
- ‚úÖ UI interactions < 300ms
- ‚úÖ No memory leaks
- ‚úÖ Efficient data structures

### Security Standards
- ‚úÖ Input validation
- ‚úÖ XSS prevention (escape HTML)
- ‚úÖ No hardcoded credentials
- ‚úÖ Secure storage practices
- ‚úÖ Error messages don't leak sensitive info

---

## üìö Reference Examples

### Proven Implementations

**Version 2.1 - HANA Connection API**
- ‚úÖ Perfect API-first example
- ‚úÖ 10/10 tests passing
- ‚úÖ Zero UI dependencies
- ‚úÖ Full JSDoc documentation
- üìÑ See: `js/api/hanaConnectionAPI.js`

**Version 2.2 - SQL Execution APIs**
- ‚úÖ Two APIs with clean separation
- ‚úÖ 30/30 tests passing
- ‚úÖ Complete feature documentation
- ‚úÖ Comprehensive summary
- üìÑ See: `SQL_EXECUTION_API_SUMMARY.md`

### Design Pattern Examples

**Dependency Injection:**
```javascript
constructor(storageService = new StorageService()) {
    this.storage = storageService; // Mockable!
}
```

**Promise-Based APIs:**
```javascript
async executeQuery(instanceId, sql) {
    return await this._execute(instanceId, sql);
}
```

**Error Handling:**
```javascript
try {
    const result = await api.execute();
    return { success: true, data: result };
} catch (error) {
    return {
        success: false,
        error: {
            message: error.message,
            code: 'ERROR_CODE',
            details: { /* additional info */ }
        }
    };
}
```

---

## ‚úÖ Success Criteria

### Feature Completion Checklist

A feature is considered complete when:

- [x] **Planning document created** with architecture and plan
- [x] **APIs implemented** with zero UI dependencies
- [x] **Tests written** with 100% method coverage
- [x] **All tests passing** in Node.js environment
- [x] **UI integrated** following Fiori guidelines
- [x] **Documentation complete** in dedicated file
- [x] **PROJECT_TRACKER updated** with version entry
- [x] **Memory tracker updated** with key knowledge
- [x] **User acceptance** - Feature approved by user

### Minimum Requirements

**To merge/deploy a feature:**
1. ‚úÖ All tests passing (100%)
2. ‚úÖ API-first proven (works in Node.js)
3. ‚úÖ Fiori compliant (uses UI5 controls)
4. ‚úÖ Documented (dedicated file + tracker)
5. ‚úÖ User approved (feedback incorporated)

---

## üöÄ Benefits of Following These Guidelines

### For Development
- **Faster iteration** - APIs tested independently
- **Better quality** - 100% test coverage standard
- **Easier debugging** - Clear separation of concerns
- **Reusable code** - APIs work everywhere

### For Maintenance
- **Clear history** - PROJECT_TRACKER documents everything
- **Easy onboarding** - Guidelines provide standards
- **Consistent patterns** - Follow proven examples
- **Reduced bugs** - Testing catches issues early

### For Users
- **Consistent UX** - Fiori guidelines ensure quality
- **Reliable features** - Thoroughly tested
- **Professional appearance** - SAP design standards
- **Better performance** - Quality standards enforced

---

## üìû Support & Resources

### Documentation
- This file: `DEVELOPMENT_GUIDELINES.md`
- Project tracker: `PROJECT_TRACKER.md` ‚≠ê Complete history + Current roadmap (single source of truth)
- Fiori guidelines: `docs/fiori/SAP_FIORI_DESIGN_GUIDELINES.md`
- HANA Cloud guides: `docs/hana-cloud/`

### Examples
- API examples: `js/api/`
- Test examples: `tests/`
- Documentation examples: Root + `docs/`

### External Resources
- SAP Fiori Design: https://experience.sap.com/fiori-design-web/
- SAP UI5 SDK: https://sapui5.hana.ondemand.com/
- SAP HANA Cloud: https://help.sap.com/docs/hana-cloud

---

## üìù Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-22 | Initial guidelines based on Version 2.1-2.2 learnings |

---

**Remember**: These guidelines exist to ensure quality, consistency, and maintainability. Following them makes development faster and more enjoyable! üéâ
