# Development Standards & Best Practices

**Version**: 2.2  
**Last Updated**: 2026-01-26 (12:00 AM - WHY Principle & User Preferences Added)
**Purpose**: Core standards for P2P Data Products development

---

## âš ï¸ CRITICAL: ARCHITECTURE-FIRST ENFORCEMENT

**MANDATORY RULE**: When user discusses architecture for 90+ minutes, IMPLEMENT ARCHITECTURE FIRST!

### The Problem We're Preventing
- âŒ User spends 90 min discussing modular architecture
- âŒ AI ignores discussion, implements features with inline/hardwired code
- âŒ Result: Double work (implement â†’ refactor), fragile code, technical debt
- âŒ User frustration: "We could have avoided this!"

### The Correct Approach
- âœ… User discusses architecture for 90+ minutes â†’ **THAT IS THE PRIORITY**
- âœ… AI asks: "Should I implement the architecture discussed before adding features?"
- âœ… AI implements: Interfaces â†’ Modules â†’ Integration â†’ THEN features
- âœ… Result: Features built on solid foundation, zero refactoring needed

### Enforcement Checklist (AI MUST DO THIS)
Before implementing ANY feature, AI must ask in `<thinking>`:
1. â“ Has user discussed architecture extensively (60+ minutes)?
2. â“ Are there unimplemented architectural concepts (interfaces, registries, DI)?
3. â“ Am I about to hardwire code that should use the discussed architecture?
4. â“ Will this create technical debt that requires later refactoring?

**If ANY answer is YES**: STOP. Ask user: "Should I implement [architecture concept] first?"

### Examples of Architecture-First Signals
- User discusses "modular architecture" for 90+ minutes â†’ Implement modules FIRST
- User discusses "dependency injection" â†’ Create interfaces FIRST
- User discusses "plugin system" â†’ Create registry FIRST
- User discusses "abstraction layer" â†’ Create abstractions FIRST

### Time Math (Why This Matters)
- **Wrong Way**: 90 min discussion + feature implementation + refactoring = **3x effort**
- **Right Way**: 90 min discussion + architecture + features = **1.5x effort**
- **Savings**: 50% less work by doing architecture first!

### Never Say This
- âŒ "We can refactor later" (= technical debt)
- âŒ "Let's get it working first" (= wrong priority)
- âŒ "Architecture is overhead" (= it's INVESTMENT)

### Always Say This
- âœ… "Should I implement the architecture we discussed first?"
- âœ… "Let me create the interfaces before the implementations"
- âœ… "I'll build this on the modular foundation we designed"

---

## ğŸ¯ PRIORITY 1: ESSENTIAL WORKFLOWS

### 1. Knowledge Graph First â­ MANDATORY

**Before ANY work, check what we already know:**

```xml
<use_mcp_tool>
  <server_name>github.com/modelcontextprotocol/servers/tree/main/src/memory</server_name>
  <tool_name>search_nodes</tool_name>
  <arguments>{"query": "[relevant search terms]"}</arguments>
</use_mcp_tool>
```

**Why**: Prevents wasting 90 minutes re-investigating known topics

**At session end**: Store new learnings in knowledge graph

---

### 1.1 Knowledge Graph: Capture the WHY â­ MANDATORY

**When creating KG entities, ALWAYS include these 8 elements:**

1. **WHAT** - The decision/action taken
2. **WHY** - The reasoning and intent behind it â­ REQUIRED
3. **PROBLEM** - What issue it solved
4. **ALTERNATIVES** - Options considered and why rejected
5. **USER CONSTRAINTS** - Specific user needs/limitations
6. **VALIDATION** - How we confirmed it worked
7. **WARNINGS** - What not to propose in future
8. **CONTEXT** - User's working style, priorities, environment

**User Philosophy**: 
> "I invest time explaining WHY and intent. Preserve that, not just the output."
> "Avoid repeating mistakes and reinventing wheels."

**Example - WRONG** âŒ:
```json
{
  "observation": "Merged frontend into app/static/"
}
```

**Example - RIGHT** âœ…:
```json
{
  "observations": [
    "WHAT: Merged frontend into app/static/",
    "WHY: User deploys together always (constraint)",
    "WHY: Debugging efficiency is daily priority",
    "PROBLEM: Separate folders slow debugging",
    "ALTERNATIVES: Keep separate (rejected - no benefit for user)",
    "USER CONSTRAINT: Single deployment unit",
    "VALIDATION: 2 bugs fixed in 5 min (merged structure helped)",
    "WARNING: Don't suggest separating frontend in future",
    "CONTEXT: User values practical > theoretical architecture"
  ]
}
```

**Benefits**:
- Next AI understands reasoning, not just outputs
- Won't re-propose rejected ideas
- Respects user's time investment in explanations
- Enables true continuous improvement

**Time cost**: +30 seconds per entity  
**Time saved**: Hours of re-explaining in future sessions

---

### 1.2 User Preferences & Constraints â­ TRACK CONTINUOUSLY

**Maintain cumulative understanding of user's working style**

**When you discover user preferences/constraints, create/update KG entity**:

```json
{
  "name": "User_Working_Preferences",
  "entityType": "user-profile",
  "observations": [
    "Prefers batch commits over frequent commits",
    "Values debugging efficiency highly (daily pain point)",
    "Deploys frontend + backend together always",
    "Works on Windows (not Mac/Linux)",
    "SAP environment context",
    "Time-sensitive - doesn't want to wait",
    "Senior-level thinking: practical > textbook",
    "Patience during learning discussions",
    "Expects explicit rules (.clinerules) to be followed"
  ]
}
```

**Add observations when user**:
- States a preference ("I prefer...")
- Mentions a constraint ("I always...")
- Shows frustration/satisfaction (indicates priority)
- Makes a trade-off decision (reveals values)
- Explains their working environment

**Benefits**:
- Future AI sessions understand user's context
- Propose compatible solutions (no Windows â†’ Mac suggestions)
- Respect user's workflow patterns
- Avoid suggesting rejected approaches

**This is separate from technical decisions** - it's about understanding WHO the user is and HOW they work.

---

### 2. Knowledge Vault Documentation â­ MANDATORY

**ALL documentation â†’ `docs/knowledge/` vault**

**âœ… ALLOWED**:
- Files in `docs/knowledge/` subdirectories
- Module READMEs: `modules/[name]/README.md`
- Links: `[[Document Name]]` format

**âŒ FORBIDDEN**:
- .md files in root (except `.clinerules`, `PROJECT_TRACKER.md`, `README.md`)
- .md files in `docs/` outside knowledge vault
- Standalone planning/summary docs

**Workflow**:
1. Search existing docs: `<search_files path="docs/knowledge" regex="..."/>`
2. Create with [[wikilinks]] to 3-5 related docs
3. Update `docs/knowledge/INDEX.md`
4. Commit doc + INDEX together

**Reference**: `docs/knowledge/README.md`

---

### 3. Check Industry Standards First ğŸ’¡

**Before proposing solutions, validate against industry best practices**

**Process**:
- Research proven approaches
- Validate user's intuitive proposals
- Use established patterns (don't reinvent)
- Only create custom when no standard exists

**Benefits**: Save time, proven quality, better collaboration

### 3.1 Infrastructure-First Principle â­ CRITICAL

**NEVER build infrastructure without immediately integrating it**

**Rule**: When building core infrastructure (registries, resolvers, interfaces):
1. âœ… Design the architecture
2. âœ… Implement the infrastructure
3. âœ… Write tests for infrastructure
4. âœ… **IMMEDIATELY integrate into application code**
5. âœ… Test the integrated system
6. âœ… Only commit when integration is complete

**Why**: 
- Infrastructure without integration = technical debt
- Quick implementations create fragile, hardwired code
- Spending 2 hours on solid architecture > 30 minutes on quick code
- "Later refactoring" never happens - debt accumulates

**Example**: Building ModuleRegistry without refactoring backend/app.py to use it = WRONG

**Correct**: Build ModuleRegistry AND refactor backend/app.py in SAME session = RIGHT

---

## ğŸ¯ PRIORITY 2: DEVELOPMENT STANDARDS

### 4. API-First Development Order â­ MANDATORY

**Principle**: Implement and stabilize APIs BEFORE creating UX

**Correct Order**:
1. âœ… Design & implement API (business logic)
2. âœ… Write unit tests (100% coverage)
3. âœ… Integrate with API Playground (manual testing)
4. âœ… **VERIFY STABLE** - API working perfectly
5. âœ… THEN design UX on top of stable API

**Requirements for "Stable"**:
- âœ… Zero UI dependencies (works in Node.js)
- âœ… Dependency injection (testable)
- âœ… Unit tests passing (100% coverage)
- âœ… Manual testing via API Playground
- âœ… Error scenarios handled
- âœ… Performance acceptable

**Why This Order Matters**:
- API bugs discovered during UX work = rework both layers
- Stable API first = UX can focus on experience, not fixing API
- Testing catches issues before UX investment
- API Playground validates before committing to UX design

**Example Workflow**:
```javascript
// 1. Implement API
class FeatureAPI {
    async getFeatures() { /* logic */ }
}

// 2. Test API (100% coverage)
test('getFeatures returns list', async () => { ... });

// 3. Test in API Playground
// Verify: GET /api/features works perfectly

// 4. ONLY THEN: Design UX
const oList = new sap.m.List({ ... });
```

**Never**: Start with UX mockup and "figure out API later"

---

### 5. Modular Architecture â­ PROJECT STANDARD

**CRITICAL ENFORCEMENT**: Run quality gate before ANY module is considered complete:
```bash
python core/quality/module_quality_gate.py [module_name]
# MUST exit 0 (PASSED) before module goes live
```

**Complete Module Structure** (ALL components REQUIRED):
```
modules/[module-name]/
â”œâ”€â”€ module.json          # MUST include backend.blueprint if backend/ exists
â”œâ”€â”€ backend/             # Python services
â”‚   â”œâ”€â”€ __init__.py      # MUST export blueprint
â”‚   â”œâ”€â”€ api.py           # MUST define Blueprint()
â”‚   â””â”€â”€ service.py
â”œâ”€â”€ tests/               # Module tests
â”œâ”€â”€ docs/                # Module docs (optional but recommended)
â””â”€â”€ README.md            # Module documentation (recommended)
```

**module.json CONTRACT** (If module has backend/):
```json
{
  "name": "module_name",
  "version": "1.0.0",
  "description": "...",
  "enabled": true,
  "category": "...",
  "structure": {
    "backend": "backend/"
  },
  "backend": {
    "blueprint": "module_api",           // â† REQUIRED
    "module_path": "modules.module_name.backend"  // â† REQUIRED
  }
}
```

**backend/__init__.py CONTRACT**:
```python
from .api import module_api  # Must export blueprint

__all__ = ['module_api']
```

**Validation Rules**:
- âœ… Module Quality Gate MUST pass (exit 0)
- âœ… No DI violations (.connection, .service, .db_path access)
- âœ… No direct module imports (loose coupling)
- âœ… Blueprint self-registers via module.json
- âœ… Uses interfaces from core.interfaces

**Benefits**: Self-contained, plug-and-play, feature-toggleable, ENFORCED quality

**Reference**: `core/quality/README.md`, `core/README.md`, [[Modular Architecture]]

**NEVER create a module without running the quality gate** - it enforces ALL these principles automatically.

---

### 5. API-First Development â­ MANDATORY

**Principle**: Implement business logic as APIs before UI

**Requirements**:
- âœ… Zero UI dependencies
- âœ… Dependency injection
- âœ… Async/Promise-based
- âœ… Works in Node.js, browser, CLI
- âœ… JSDoc documented

**Example**:
```javascript
export class FeatureAPI {
    constructor(storageService) {
        this.storage = storageService; // Injected!
    }
    
    async getData() {
        return await this.storage.load(); // Pure logic
    }
}
```

---

### 6. Comprehensive Testing â­ MANDATORY

**Standards**:
- âœ… 100% API method coverage
- âœ… Tests run in Node.js (not browser)
- âœ… Tests run in < 5 seconds
- âœ… Mock dependencies for isolation
- âœ… Test success AND error scenarios

**UI Testing**:
- âœ… Use jsdom for browser simulation
- âœ… Catch SAP UI5 API misuse
- âœ… Tests run in < 10 seconds

**Reference**: [[Testing Standards]] in knowledge vault

---

### 7. SAP Fiori Compliance â­ MANDATORY

**Critical Rules**:
1. âœ… **Use standard controls first** (InputListItem, not CustomListItem)
2. âœ… **No CSS hacks** (no !important, no custom padding overrides)
3. âœ… **Pure JavaScript preferred** (easier debugging than XML)
4. âœ… **Start simple** (title + one control â†’ incremental complexity)

**Quick Check**:
- Which Fiori control for this purpose?
- Standard control available? Use it!
- Need CSS fix? Wrong control chosen!

**Reference**: [[SAP Fiori Design Standards]], [[InputListItem Control Decision]]

---

## ğŸ¯ PRIORITY 3: OPERATIONAL PRACTICES

### 8. Application Logging

**Purpose**: Primarily for AI assistant troubleshooting

**Log**:
- âœ… API calls, database queries, errors
- âœ… Performance metrics, business decisions
- âŒ Sensitive data, debug statements

**When issues occur**: Check logs FIRST via UI "Logs" button

---

### 9. Git Workflow

**AI Does**:
- âœ… Stage: `git add <files>`
- âœ… Commit: `git commit -m "msg"`
- âœ… Tag milestones: `git tag -a vX.Y-name`

**AI Does NOT**:
- âŒ Push to GitHub (user decides when)
- âŒ Pull changes
- âŒ Remote operations

**Tagging**: Major milestones only (not minor fixes)

---

### 10. Project Tracker

**Update `PROJECT_TRACKER.md` after**:
- âœ… Feature completion
- âœ… Major refactoring
- âœ… Bug fixes
- âœ… Architecture changes

**Format**: Version entry with objectives, work performed, metrics, status

---

## ğŸ“‹ AI ASSISTANT CHECKLIST

**Before implementing features**:

1. âœ… Check knowledge graph
2. âœ… Check knowledge vault docs
3. âœ… **ASK: Should I implement discussed architecture first?** â­ NEW
4. âœ… Create compliance checklist (all 7 requirements)
5. âœ… Estimate FULL time (tests + docs + tracker)
6. âœ… Get user approval
7. âœ… Follow ALL steps
8. âœ… Self-audit before commit

**NO SHORTCUTS**: Implement fewer features correctly, not more features poorly

---

## ğŸ“ Quick Reference

### Fiori UI Development
- Standard controls first
- No CSS hacks
- Pure JavaScript
- Start simple, build incrementally
- Check: [[SAP Fiori Design Standards]]

### Testing
- 100% API coverage
- Node.js tests < 5s
- UI tests < 10s
- Check: [[Testing Standards]]

### Architecture
- Modular structure: `modules/[name]/backend/`
- Feature toggleable
- Self-documented
- Check: [[Modular Architecture]]

### Documentation
- Knowledge vault: `docs/knowledge/`
- Use [[wikilinks]]
- Update INDEX.md
- Check: `docs/knowledge/README.md`

### Git
- Clear commit messages
- AI commits, user pushes
- Tags for milestones only
- Update PROJECT_TRACKER.md

---

## ğŸ“š Key References

**Knowledge Vault** (â­ Start here):
- `docs/knowledge/INDEX.md` - All documentation
- [[SAP Fiori Design Standards]]
- [[Testing Standards]]
- [[Modular Architecture]]
- [[HANA Connection Module]]

**Legacy Docs** (detailed references):
- Fiori: `docs/fiori/SAP_FIORI_DESIGN_GUIDELINES.md`
- HANA: `docs/hana-cloud/` (25+ guides)
- Planning: `docs/planning/` (architecture & features)

---

**Summary**: Follow Priority 1 (essential workflows), then Priority 2 (development standards), then Priority 3 (operational practices). Reference knowledge vault for detailed guidance.